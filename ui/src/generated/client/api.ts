// tslint:disable
/**
 * service.proto
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * availability represents the availability classification levels.   - alpha: alpha is completely experemental, and is not expected to work in any way.  - beta: beta is being tested, and is expected to work with minor issues.  - stable: stable is available for public consumption, and works without issue.  - default: default is stable, and available for customer demo consumption. Exactly 1 flavor should be configured as default.
 * @export
 * @enum {string}
 */
export enum Flavoravailability {
  Alpha = 'alpha',
  Beta = 'beta',
  Stable = 'stable',
  Default = 'default',
}

/**
 * method represents the various lifespan operations.   - REPLACE: REPLACE indicates that the given lifespan should replace the current lifespan.  - ADD: ADD indicates that the given lifespan should be added to the current lifespan.  - SUBTRACT: SUBTRACT indicates that the given lifespan should be subtracted from the current lifespan.
 * @export
 * @enum {string}
 */
export enum LifespanRequestMethod {
  REPLACE = 'REPLACE',
  ADD = 'ADD',
  SUBTRACT = 'SUBTRACT',
}

/**
 *
 * @export
 * @interface V1Artifact
 */
export interface V1Artifact {
  /**
   *
   * @type {string}
   * @memberof V1Artifact
   */
  Name?: string;
  /**
   *
   * @type {string}
   * @memberof V1Artifact
   */
  Description?: string;
  /**
   *
   * @type {string}
   * @memberof V1Artifact
   */
  URL?: string;
}
/**
 * Cluster represents a single cluster.
 * @export
 * @interface V1Cluster
 */
export interface V1Cluster {
  /**
   * ID is the unique ID for the cluster.
   * @type {string}
   * @memberof V1Cluster
   */
  ID?: string;
  /**
   *
   * @type {V1Status}
   * @memberof V1Cluster
   */
  Status?: V1Status;
  /**
   * Flavor is the original flavor ID that launched this cluster.
   * @type {string}
   * @memberof V1Cluster
   */
  Flavor?: string;
  /**
   * Owner is the email address for the cluster owner.
   * @type {string}
   * @memberof V1Cluster
   */
  Owner?: string;
  /**
   * CreatedOn is the timestamp on which the cluster started being created.
   * @type {string}
   * @memberof V1Cluster
   */
  CreatedOn?: string;
  /**
   * DestroyedOn is the timestamp on which the cluster finished being destroyed.
   * @type {string}
   * @memberof V1Cluster
   */
  DestroyedOn?: string;
  /**
   * Lifespan is the duration for which the cluster should be kept alive.
   * @type {string}
   * @memberof V1Cluster
   */
  Lifespan?: string;
  /**
   * Description is a human readable description for the cluster.
   * @type {string}
   * @memberof V1Cluster
   */
  Description?: string;
  /**
   * URL is an optional URL for this cluster.
   * @type {string}
   * @memberof V1Cluster
   */
  URL?: string;
}
/**
 *
 * @export
 * @interface V1ClusterArtifacts
 */
export interface V1ClusterArtifacts {
  /**
   *
   * @type {Array<V1Artifact>}
   * @memberof V1ClusterArtifacts
   */
  Artifacts?: Array<V1Artifact>;
}
/**
 * ClusterListResponse represents details about all clusters.
 * @export
 * @interface V1ClusterListResponse
 */
export interface V1ClusterListResponse {
  /**
   * Clusters is a list of all clusters.
   * @type {Array<V1Cluster>}
   * @memberof V1ClusterListResponse
   */
  Clusters?: Array<V1Cluster>;
}
/**
 * CreateClusterRequest represents details for launching a new cluster.
 * @export
 * @interface V1CreateClusterRequest
 */
export interface V1CreateClusterRequest {
  /**
   * ID is the flavor ID to launch.
   * @type {string}
   * @memberof V1CreateClusterRequest
   */
  ID?: string;
  /**
   * Lifespan is the initial cluster lifespan.
   * @type {string}
   * @memberof V1CreateClusterRequest
   */
  Lifespan?: string;
  /**
   * Parameters is a map of launch parameter names to values.
   * @type {{ [key: string]: string; }}
   * @memberof V1CreateClusterRequest
   */
  Parameters?: { [key: string]: string };
  /**
   * Description is a human readable description for the cluster.
   * @type {string}
   * @memberof V1CreateClusterRequest
   */
  Description?: string;
  /**
   * NoSlack is used to skip sending Slack messages for cluster lifecycle events.
   * @type {boolean}
   * @memberof V1CreateClusterRequest
   */
  NoSlack?: boolean;
}
/**
 * Flavor represents a configured cluster flavor.
 * @export
 * @interface V1Flavor
 */
export interface V1Flavor {
  /**
   * ID is the unique, human type-able, ID for the flavor.
   * @type {string}
   * @memberof V1Flavor
   */
  ID?: string;
  /**
   * Name is a human readable name for the flavor.
   * @type {string}
   * @memberof V1Flavor
   */
  Name?: string;
  /**
   * Description is a human readable description for the flavor.
   * @type {string}
   * @memberof V1Flavor
   */
  Description?: string;
  /**
   *
   * @type {Flavoravailability}
   * @memberof V1Flavor
   */
  Availability?: Flavoravailability;
  /**
   * Parameters is a map of parameters required for launching this flavor.
   * @type {{ [key: string]: V1Parameter; }}
   * @memberof V1Flavor
   */
  Parameters?: { [key: string]: V1Parameter };
  /**
   * Artifacts is a map of artifacts produced by this flavor.
   * @type {{ [key: string]: V1FlavorArtifact; }}
   * @memberof V1Flavor
   */
  Artifacts?: { [key: string]: V1FlavorArtifact };
}
/**
 * FlavorArtifact represents a single artifact that is produced by a flavor.
 * @export
 * @interface V1FlavorArtifact
 */
export interface V1FlavorArtifact {
  /**
   * Name is the unique name of the artifact.
   * @type {string}
   * @memberof V1FlavorArtifact
   */
  Name?: string;
  /**
   * Description is a human readable description for the artifact.
   * @type {string}
   * @memberof V1FlavorArtifact
   */
  Description?: string;
  /**
   * Tags is a set of artifact tags.
   * @type {{ [key: string]: object; }}
   * @memberof V1FlavorArtifact
   */
  Tags?: { [key: string]: object };
}
/**
 * FlavorListResponse represents details about the available cluster flavors.
 * @export
 * @interface V1FlavorListResponse
 */
export interface V1FlavorListResponse {
  /**
   * Default is the flavor ID of the default cluster flavor.
   * @type {string}
   * @memberof V1FlavorListResponse
   */
  Default?: string;
  /**
   * Flavors is a list of all available cluster flavors.
   * @type {Array<V1Flavor>}
   * @memberof V1FlavorListResponse
   */
  Flavors?: Array<V1Flavor>;
}
/**
 *
 * @export
 * @interface V1LifespanRequest
 */
export interface V1LifespanRequest {
  /**
   * ID is the unique ID for the cluster.
   * @type {string}
   * @memberof V1LifespanRequest
   */
  id?: string;
  /**
   * Lifespan is the new lifespan.
   * @type {string}
   * @memberof V1LifespanRequest
   */
  Lifespan?: string;
  /**
   *
   * @type {LifespanRequestMethod}
   * @memberof V1LifespanRequest
   */
  method?: LifespanRequestMethod;
}
/**
 * Log represents the logs from a specific pod.
 * @export
 * @interface V1Log
 */
export interface V1Log {
  /**
   * Name is the name given to this pod in the workflow.
   * @type {string}
   * @memberof V1Log
   */
  Name?: string;
  /**
   * Started is the time at which this pod was started. Used for ordering between pods.
   * @type {string}
   * @memberof V1Log
   */
  Started?: string;
  /**
   * Body is the raw pod logs.
   * @type {string}
   * @memberof V1Log
   */
  Body?: string;
}
/**
 * LogsResponse represents a collection of logs.
 * @export
 * @interface V1LogsResponse
 */
export interface V1LogsResponse {
  /**
   * Logs are all of the logs from a cluster.
   * @type {Array<V1Log>}
   * @memberof V1LogsResponse
   */
  Logs?: Array<V1Log>;
}
/**
 * Parameter represents a single parameter that is needed to launch a flavor.
 * @export
 * @interface V1Parameter
 */
export interface V1Parameter {
  /**
   * Name is the unique name of the parameter.
   * @type {string}
   * @memberof V1Parameter
   */
  Name?: string;
  /**
   * Description is a human readable description for the parameter.
   * @type {string}
   * @memberof V1Parameter
   */
  Description?: string;
  /**
   * Value that this parameter could have. If the parameter is not optional, then value serves as an example. If the parameter is optional, then value serves as a default. If the parameter is internal, then value serves as a hardcoded constant.
   * @type {string}
   * @memberof V1Parameter
   */
  Value?: string;
  /**
   * Optional indicates that this parameter can be optionally provided by a user. If the user does not provide a value, then Value serves as a default.
   * @type {boolean}
   * @memberof V1Parameter
   */
  Optional?: boolean;
  /**
   * Internal indicates that this parameter should not be provided by a user, but rather treats Value as a hardcoded constant.
   * @type {boolean}
   * @memberof V1Parameter
   */
  Internal?: boolean;
  /**
   * The relative order of importance of this parameter for when presenting in a UI for example.
   * @type {number}
   * @memberof V1Parameter
   */
  Order?: number;
  /**
   *
   * @type {string}
   * @memberof V1Parameter
   */
  Help?: string;
}
/**
 * ResourceByID represents a generic reference to a named/unique resource.
 * @export
 * @interface V1ResourceByID
 */
export interface V1ResourceByID {
  /**
   *
   * @type {string}
   * @memberof V1ResourceByID
   */
  id?: string;
}
/**
 * ServiceAccount represents an authenticated service account (robot) principal.
 * @export
 * @interface V1ServiceAccount
 */
export interface V1ServiceAccount {
  /**
   * Name is a human readable name for the service account.
   * @type {string}
   * @memberof V1ServiceAccount
   */
  Name?: string;
  /**
   * Description is a human readable description for the service account.
   * @type {string}
   * @memberof V1ServiceAccount
   */
  Description?: string;
  /**
   * Email is the StackRox email address for the service account.
   * @type {string}
   * @memberof V1ServiceAccount
   */
  Email?: string;
}
/**
 * Status represents the various cluster states.   - FAILED: FAILED is the state when the cluster has failed in one way or another.  - CREATING: CREATING is the state when the cluster is being created.  - READY: READY is the state when the cluster is available and ready for use.  - DESTROYING: DESTROYING is the state when the cluster is being destroyed.  - FINISHED: FINISHED is the state when the cluster has been successfully destroyed.
 * @export
 * @enum {string}
 */
export enum V1Status {
  FAILED = 'FAILED',
  CREATING = 'CREATING',
  READY = 'READY',
  DESTROYING = 'DESTROYING',
  FINISHED = 'FINISHED',
}

/**
 *
 * @export
 * @interface V1TokenResponse
 */
export interface V1TokenResponse {
  /**
   *
   * @type {V1ServiceAccount}
   * @memberof V1TokenResponse
   */
  Account?: V1ServiceAccount;
  /**
   * Token is the token generated for the service account.
   * @type {string}
   * @memberof V1TokenResponse
   */
  Token?: string;
}
/**
 * User represents an authenticated (human) principal.
 * @export
 * @interface V1User
 */
export interface V1User {
  /**
   * Expiry is the expiration date of this user session. Used only as a hint to the user and not for enforcement.
   * @type {string}
   * @memberof V1User
   */
  Expiry?: string;
  /**
   * Name is the full name of the user.
   * @type {string}
   * @memberof V1User
   */
  Name?: string;
  /**
   * Email is the email address of the user.
   * @type {string}
   * @memberof V1User
   */
  Email?: string;
  /**
   * Picture is a URL linking to this user\'s profile picture, if available.
   * @type {string}
   * @memberof V1User
   */
  Picture?: string;
}
/**
 *
 * @export
 * @interface V1Version
 */
export interface V1Version {
  /**
   *
   * @type {string}
   * @memberof V1Version
   */
  BuildDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1Version
   */
  GitCommit?: string;
  /**
   *
   * @type {string}
   * @memberof V1Version
   */
  GoVersion?: string;
  /**
   *
   * @type {string}
   * @memberof V1Version
   */
  Platform?: string;
  /**
   *
   * @type {string}
   * @memberof V1Version
   */
  Version?: string;
  /**
   *
   * @type {string}
   * @memberof V1Version
   */
  Workflow?: string;
}
/**
 * WhoamiResponse represents details about the current authenticated principal.
 * @export
 * @interface V1WhoamiResponse
 */
export interface V1WhoamiResponse {
  /**
   *
   * @type {V1User}
   * @memberof V1WhoamiResponse
   */
  User?: V1User;
  /**
   *
   * @type {V1ServiceAccount}
   * @memberof V1WhoamiResponse
   */
  ServiceAccount?: V1ServiceAccount;
}

/**
 * ClusterServiceApi - axios parameter creator
 * @export
 */
export const ClusterServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete deletes an existing cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(id: string, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling _delete.'
        );
      }
      const localVarPath = `/v1/cluster/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Artifacts returns the artifacts for a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    artifacts(id: string, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling artifacts.'
        );
      }
      const localVarPath = `/v1/cluster/{id}/artifacts`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create launches a new cluster.
     * @param {V1CreateClusterRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(body: V1CreateClusterRequest, options: any = {}): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling create.'
        );
      }
      const localVarPath = `/v1/cluster`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    info(id: string, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling info.'
        );
      }
      const localVarPath = `/v1/cluster/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Token generates a service account token for the current user.
     * @param {string} id ID is the unique ID for the cluster.
     * @param {V1LifespanRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lifespan(id: string, body: V1LifespanRequest, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling lifespan.'
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling lifespan.'
        );
      }
      const localVarPath = `/v1/cluster/{id}/lifespan`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {boolean} [all] all indicates that all clusters should be returned, not just the ones owned by the user.
     * @param {boolean} [expired] expired indicates that expired clusters should be returned, not just the ones that are launching/ready.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(all?: boolean, expired?: boolean, options: any = {}): RequestArgs {
      const localVarPath = `/v1/cluster`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (all !== undefined) {
        localVarQueryParameter['all'] = all;
      }

      if (expired !== undefined) {
        localVarQueryParameter['expired'] = expired;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Logs returns the logs for a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logs(id: string, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling logs.'
        );
      }
      const localVarPath = `/v1/cluster/{id}/logs`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ClusterServiceApi - functional programming interface
 * @export
 */
export const ClusterServiceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete deletes an existing cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(
      id: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = ClusterServiceApiAxiosParamCreator(configuration)._delete(
        id,
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Artifacts returns the artifacts for a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    artifacts(
      id: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ClusterArtifacts> {
      const localVarAxiosArgs = ClusterServiceApiAxiosParamCreator(configuration).artifacts(
        id,
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Create launches a new cluster.
     * @param {V1CreateClusterRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      body: V1CreateClusterRequest,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ResourceByID> {
      const localVarAxiosArgs = ClusterServiceApiAxiosParamCreator(configuration).create(
        body,
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    info(
      id: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Cluster> {
      const localVarAxiosArgs = ClusterServiceApiAxiosParamCreator(configuration).info(id, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Token generates a service account token for the current user.
     * @param {string} id ID is the unique ID for the cluster.
     * @param {V1LifespanRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lifespan(
      id: string,
      body: V1LifespanRequest,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
      const localVarAxiosArgs = ClusterServiceApiAxiosParamCreator(configuration).lifespan(
        id,
        body,
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {boolean} [all] all indicates that all clusters should be returned, not just the ones owned by the user.
     * @param {boolean} [expired] expired indicates that expired clusters should be returned, not just the ones that are launching/ready.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      all?: boolean,
      expired?: boolean,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ClusterListResponse> {
      const localVarAxiosArgs = ClusterServiceApiAxiosParamCreator(configuration).list(
        all,
        expired,
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Logs returns the logs for a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logs(
      id: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1LogsResponse> {
      const localVarAxiosArgs = ClusterServiceApiAxiosParamCreator(configuration).logs(id, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * ClusterServiceApi - factory interface
 * @export
 */
export const ClusterServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Delete deletes an existing cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(id: string, options?: any): AxiosPromise<object> {
      return ClusterServiceApiFp(configuration)._delete(id, options)(axios, basePath);
    },
    /**
     *
     * @summary Artifacts returns the artifacts for a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    artifacts(id: string, options?: any): AxiosPromise<V1ClusterArtifacts> {
      return ClusterServiceApiFp(configuration).artifacts(id, options)(axios, basePath);
    },
    /**
     *
     * @summary Create launches a new cluster.
     * @param {V1CreateClusterRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(body: V1CreateClusterRequest, options?: any): AxiosPromise<V1ResourceByID> {
      return ClusterServiceApiFp(configuration).create(body, options)(axios, basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    info(id: string, options?: any): AxiosPromise<V1Cluster> {
      return ClusterServiceApiFp(configuration).info(id, options)(axios, basePath);
    },
    /**
     *
     * @summary Token generates a service account token for the current user.
     * @param {string} id ID is the unique ID for the cluster.
     * @param {V1LifespanRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lifespan(id: string, body: V1LifespanRequest, options?: any): AxiosPromise<string> {
      return ClusterServiceApiFp(configuration).lifespan(id, body, options)(axios, basePath);
    },
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {boolean} [all] all indicates that all clusters should be returned, not just the ones owned by the user.
     * @param {boolean} [expired] expired indicates that expired clusters should be returned, not just the ones that are launching/ready.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(all?: boolean, expired?: boolean, options?: any): AxiosPromise<V1ClusterListResponse> {
      return ClusterServiceApiFp(configuration).list(all, expired, options)(axios, basePath);
    },
    /**
     *
     * @summary Logs returns the logs for a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logs(id: string, options?: any): AxiosPromise<V1LogsResponse> {
      return ClusterServiceApiFp(configuration).logs(id, options)(axios, basePath);
    },
  };
};

/**
 * ClusterServiceApi - object-oriented interface
 * @export
 * @class ClusterServiceApi
 * @extends {BaseAPI}
 */
export class ClusterServiceApi extends BaseAPI {
  /**
   *
   * @summary Delete deletes an existing cluster.
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public _delete(id: string, options?: any) {
    return ClusterServiceApiFp(this.configuration)._delete(id, options)(this.axios, this.basePath);
  }

  /**
   *
   * @summary Artifacts returns the artifacts for a specific cluster.
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public artifacts(id: string, options?: any) {
    return ClusterServiceApiFp(this.configuration).artifacts(id, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   *
   * @summary Create launches a new cluster.
   * @param {V1CreateClusterRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public create(body: V1CreateClusterRequest, options?: any) {
    return ClusterServiceApiFp(this.configuration).create(body, options)(this.axios, this.basePath);
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public info(id: string, options?: any) {
    return ClusterServiceApiFp(this.configuration).info(id, options)(this.axios, this.basePath);
  }

  /**
   *
   * @summary Token generates a service account token for the current user.
   * @param {string} id ID is the unique ID for the cluster.
   * @param {V1LifespanRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public lifespan(id: string, body: V1LifespanRequest, options?: any) {
    return ClusterServiceApiFp(this.configuration).lifespan(
      id,
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary CreateToken generates an arbitrary service account token
   * @param {boolean} [all] all indicates that all clusters should be returned, not just the ones owned by the user.
   * @param {boolean} [expired] expired indicates that expired clusters should be returned, not just the ones that are launching/ready.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public list(all?: boolean, expired?: boolean, options?: any) {
    return ClusterServiceApiFp(this.configuration).list(
      all,
      expired,
      options
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Logs returns the logs for a specific cluster.
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public logs(id: string, options?: any) {
    return ClusterServiceApiFp(this.configuration).logs(id, options)(this.axios, this.basePath);
  }
}

/**
 * FlavorServiceApi - axios parameter creator
 * @export
 */
export const FlavorServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    info(id: string, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling info.'
        );
      }
      const localVarPath = `/v1/flavor/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(options: any = {}): RequestArgs {
      const localVarPath = `/v1/flavor`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FlavorServiceApi - functional programming interface
 * @export
 */
export const FlavorServiceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    info(
      id: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Flavor> {
      const localVarAxiosArgs = FlavorServiceApiAxiosParamCreator(configuration).info(id, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1FlavorListResponse> {
      const localVarAxiosArgs = FlavorServiceApiAxiosParamCreator(configuration).list(options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * FlavorServiceApi - factory interface
 * @export
 */
export const FlavorServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    info(id: string, options?: any): AxiosPromise<V1Flavor> {
      return FlavorServiceApiFp(configuration).info(id, options)(axios, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(options?: any): AxiosPromise<V1FlavorListResponse> {
      return FlavorServiceApiFp(configuration).list(options)(axios, basePath);
    },
  };
};

/**
 * FlavorServiceApi - object-oriented interface
 * @export
 * @class FlavorServiceApi
 * @extends {BaseAPI}
 */
export class FlavorServiceApi extends BaseAPI {
  /**
   *
   * @summary CreateToken generates an arbitrary service account token
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlavorServiceApi
   */
  public info(id: string, options?: any) {
    return FlavorServiceApiFp(this.configuration).info(id, options)(this.axios, this.basePath);
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlavorServiceApi
   */
  public list(options?: any) {
    return FlavorServiceApiFp(this.configuration).list(options)(this.axios, this.basePath);
  }
}

/**
 * UserServiceApi - axios parameter creator
 * @export
 */
export const UserServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {V1ServiceAccount} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken(body: V1ServiceAccount, options: any = {}): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createToken.'
        );
      }
      const localVarPath = `/v1/token-create`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Token generates a service account token for the current user.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    token(body: object, options: any = {}): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling token.'
        );
      }
      const localVarPath = `/v1/token`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami(options: any = {}): RequestArgs {
      const localVarPath = `/v1/whoami`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserServiceApi - functional programming interface
 * @export
 */
export const UserServiceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {V1ServiceAccount} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken(
      body: V1ServiceAccount,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1TokenResponse> {
      const localVarAxiosArgs = UserServiceApiAxiosParamCreator(configuration).createToken(
        body,
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Token generates a service account token for the current user.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    token(
      body: object,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1TokenResponse> {
      const localVarAxiosArgs = UserServiceApiAxiosParamCreator(configuration).token(body, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami(
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1WhoamiResponse> {
      const localVarAxiosArgs = UserServiceApiAxiosParamCreator(configuration).whoami(options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * UserServiceApi - factory interface
 * @export
 */
export const UserServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {V1ServiceAccount} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken(body: V1ServiceAccount, options?: any): AxiosPromise<V1TokenResponse> {
      return UserServiceApiFp(configuration).createToken(body, options)(axios, basePath);
    },
    /**
     *
     * @summary Token generates a service account token for the current user.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    token(body: object, options?: any): AxiosPromise<V1TokenResponse> {
      return UserServiceApiFp(configuration).token(body, options)(axios, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami(options?: any): AxiosPromise<V1WhoamiResponse> {
      return UserServiceApiFp(configuration).whoami(options)(axios, basePath);
    },
  };
};

/**
 * UserServiceApi - object-oriented interface
 * @export
 * @class UserServiceApi
 * @extends {BaseAPI}
 */
export class UserServiceApi extends BaseAPI {
  /**
   *
   * @summary CreateToken generates an arbitrary service account token
   * @param {V1ServiceAccount} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserServiceApi
   */
  public createToken(body: V1ServiceAccount, options?: any) {
    return UserServiceApiFp(this.configuration).createToken(body, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   *
   * @summary Token generates a service account token for the current user.
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserServiceApi
   */
  public token(body: object, options?: any) {
    return UserServiceApiFp(this.configuration).token(body, options)(this.axios, this.basePath);
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserServiceApi
   */
  public whoami(options?: any) {
    return UserServiceApiFp(this.configuration).whoami(options)(this.axios, this.basePath);
  }
}

/**
 * VersionServiceApi - axios parameter creator
 * @export
 */
export const VersionServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion(options: any = {}): RequestArgs {
      const localVarPath = `/v1/version`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VersionServiceApi - functional programming interface
 * @export
 */
export const VersionServiceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion(
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Version> {
      const localVarAxiosArgs = VersionServiceApiAxiosParamCreator(configuration).getVersion(
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * VersionServiceApi - factory interface
 * @export
 */
export const VersionServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion(options?: any): AxiosPromise<V1Version> {
      return VersionServiceApiFp(configuration).getVersion(options)(axios, basePath);
    },
  };
};

/**
 * VersionServiceApi - object-oriented interface
 * @export
 * @class VersionServiceApi
 * @extends {BaseAPI}
 */
export class VersionServiceApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VersionServiceApi
   */
  public getVersion(options?: any) {
    return VersionServiceApiFp(this.configuration).getVersion(options)(this.axios, this.basePath);
  }
}
