/* tslint:disable */
/* eslint-disable */
/**
 * proto/api/v1/service.proto
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Status represents the various cluster states.   - FAILED: FAILED is the state when the cluster has failed in one way or another.  - CREATING: CREATING is the state when the cluster is being created.  - READY: READY is the state when the cluster is available and ready for use.  - DESTROYING: DESTROYING is the state when the cluster is being destroyed.  - FINISHED: FINISHED is the state when the cluster has been successfully destroyed.
 * @export
 * @enum {string}
 */

export const Apiv1Status = {
    Failed: 'FAILED',
    Creating: 'CREATING',
    Ready: 'READY',
    Destroying: 'DESTROYING',
    Finished: 'FINISHED'
} as const;

export type Apiv1Status = typeof Apiv1Status[keyof typeof Apiv1Status];


/**
 * 
 * @export
 * @interface ClusterServiceLifespanRequest
 */
export interface ClusterServiceLifespanRequest {
    /**
     * Lifespan is the new lifespan.
     * @type {string}
     * @memberof ClusterServiceLifespanRequest
     */
    'Lifespan'?: string;
    /**
     * 
     * @type {LifespanRequestMethod}
     * @memberof ClusterServiceLifespanRequest
     */
    'method'?: LifespanRequestMethod;
}


/**
 * availability represents the availability classification levels.   - alpha: alpha is completely experemental, and is not expected to work in any way.  - beta: beta is being tested, and is expected to work with minor issues.  - stable: stable is available for public consumption, and works without issue.  - default: default is stable, and available for customer demo consumption. Exactly 1 flavor should be configured as default.
 * @export
 * @enum {string}
 */

export const Flavoravailability = {
    Alpha: 'alpha',
    Beta: 'beta',
    Stable: 'stable',
    Default: 'default'
} as const;

export type Flavoravailability = typeof Flavoravailability[keyof typeof Flavoravailability];


/**
 * 
 * @export
 * @interface GooglerpcStatus
 */
export interface GooglerpcStatus {
    /**
     * 
     * @type {number}
     * @memberof GooglerpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GooglerpcStatus
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof GooglerpcStatus
     */
    'details'?: Array<ProtobufAny>;
}
/**
 * method represents the various lifespan operations.   - REPLACE: REPLACE indicates that the given lifespan should replace the current lifespan.  - ADD: ADD indicates that the given lifespan should be added to the current lifespan.  - SUBTRACT: SUBTRACT indicates that the given lifespan should be subtracted from the current lifespan.
 * @export
 * @enum {string}
 */

export const LifespanRequestMethod = {
    Replace: 'REPLACE',
    Add: 'ADD',
    Subtract: 'SUBTRACT'
} as const;

export type LifespanRequestMethod = typeof LifespanRequestMethod[keyof typeof LifespanRequestMethod];


/**
 * 
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof ProtobufAny
     */
    '@type'?: string;
}
/**
 * 
 * @export
 * @interface StreamResultOfV1CliUpgradeResponse
 */
export interface StreamResultOfV1CliUpgradeResponse {
    /**
     * 
     * @type {V1CliUpgradeResponse}
     * @memberof StreamResultOfV1CliUpgradeResponse
     */
    'result'?: V1CliUpgradeResponse;
    /**
     * 
     * @type {GooglerpcStatus}
     * @memberof StreamResultOfV1CliUpgradeResponse
     */
    'error'?: GooglerpcStatus;
}
/**
 * 
 * @export
 * @interface V1Artifact
 */
export interface V1Artifact {
    /**
     * 
     * @type {string}
     * @memberof V1Artifact
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Artifact
     */
    'Description'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Artifact
     */
    'URL'?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Artifact
     */
    'Mode'?: number;
}
/**
 * 
 * @export
 * @interface V1CliUpgradeResponse
 */
export interface V1CliUpgradeResponse {
    /**
     * 
     * @type {string}
     * @memberof V1CliUpgradeResponse
     */
    'fileChunk'?: string;
}
/**
 * Cluster represents a single cluster.
 * @export
 * @interface V1Cluster
 */
export interface V1Cluster {
    /**
     * ID is the unique ID for the cluster.
     * @type {string}
     * @memberof V1Cluster
     */
    'ID'?: string;
    /**
     * 
     * @type {Apiv1Status}
     * @memberof V1Cluster
     */
    'Status'?: Apiv1Status;
    /**
     * Flavor is the original flavor ID that launched this cluster.
     * @type {string}
     * @memberof V1Cluster
     */
    'Flavor'?: string;
    /**
     * Owner is the email address for the cluster owner.
     * @type {string}
     * @memberof V1Cluster
     */
    'Owner'?: string;
    /**
     * CreatedOn is the timestamp on which the cluster started being created.
     * @type {string}
     * @memberof V1Cluster
     */
    'CreatedOn'?: string;
    /**
     * DestroyedOn is the timestamp on which the cluster finished being destroyed.
     * @type {string}
     * @memberof V1Cluster
     */
    'DestroyedOn'?: string;
    /**
     * Lifespan is the duration for which the cluster should be kept alive.
     * @type {string}
     * @memberof V1Cluster
     */
    'Lifespan'?: string;
    /**
     * Description is a human readable description for the cluster.
     * @type {string}
     * @memberof V1Cluster
     */
    'Description'?: string;
    /**
     * URL is an optional URL for this cluster.
     * @type {string}
     * @memberof V1Cluster
     */
    'URL'?: string;
    /**
     * Connect is a command to add kube connection information to kubeconfig.
     * @type {string}
     * @memberof V1Cluster
     */
    'Connect'?: string;
}


/**
 * 
 * @export
 * @interface V1ClusterArtifacts
 */
export interface V1ClusterArtifacts {
    /**
     * 
     * @type {Array<V1Artifact>}
     * @memberof V1ClusterArtifacts
     */
    'Artifacts'?: Array<V1Artifact>;
}
/**
 * ClusterListResponse represents details about all clusters.
 * @export
 * @interface V1ClusterListResponse
 */
export interface V1ClusterListResponse {
    /**
     * Clusters is a list of all clusters.
     * @type {Array<V1Cluster>}
     * @memberof V1ClusterListResponse
     */
    'Clusters'?: Array<V1Cluster>;
}
/**
 * CreateClusterRequest represents details for launching a new cluster.
 * @export
 * @interface V1CreateClusterRequest
 */
export interface V1CreateClusterRequest {
    /**
     * ID is the flavor ID to launch.
     * @type {string}
     * @memberof V1CreateClusterRequest
     */
    'ID'?: string;
    /**
     * Lifespan is the initial cluster lifespan.
     * @type {string}
     * @memberof V1CreateClusterRequest
     */
    'Lifespan'?: string;
    /**
     * Parameters is a map of launch parameter names to values.
     * @type {{ [key: string]: string; }}
     * @memberof V1CreateClusterRequest
     */
    'Parameters'?: { [key: string]: string; };
    /**
     * Description is a human readable description for the cluster.
     * @type {string}
     * @memberof V1CreateClusterRequest
     */
    'Description'?: string;
    /**
     * NoSlack is used to skip sending Slack messages for cluster lifecycle events.
     * @type {boolean}
     * @memberof V1CreateClusterRequest
     */
    'NoSlack'?: boolean;
    /**
     * SlackDM is used to choose direct messages for cluster lifecycle events.
     * @type {boolean}
     * @memberof V1CreateClusterRequest
     */
    'SlackDM'?: boolean;
}
/**
 * Flavor represents a configured cluster flavor.
 * @export
 * @interface V1Flavor
 */
export interface V1Flavor {
    /**
     * ID is the unique, human type-able, ID for the flavor.
     * @type {string}
     * @memberof V1Flavor
     */
    'ID'?: string;
    /**
     * Name is a human readable name for the flavor.
     * @type {string}
     * @memberof V1Flavor
     */
    'Name'?: string;
    /**
     * Description is a human readable description for the flavor.
     * @type {string}
     * @memberof V1Flavor
     */
    'Description'?: string;
    /**
     * 
     * @type {Flavoravailability}
     * @memberof V1Flavor
     */
    'Availability'?: Flavoravailability;
    /**
     * Parameters is a map of parameters required for launching this flavor.
     * @type {{ [key: string]: V1Parameter; }}
     * @memberof V1Flavor
     */
    'Parameters'?: { [key: string]: V1Parameter; };
    /**
     * Artifacts is a map of artifacts produced by this flavor.
     * @type {{ [key: string]: V1FlavorArtifact; }}
     * @memberof V1Flavor
     */
    'Artifacts'?: { [key: string]: V1FlavorArtifact; };
}


/**
 * FlavorArtifact represents a single artifact that is produced by a flavor.
 * @export
 * @interface V1FlavorArtifact
 */
export interface V1FlavorArtifact {
    /**
     * Name is the unique name of the artifact.
     * @type {string}
     * @memberof V1FlavorArtifact
     */
    'Name'?: string;
    /**
     * Description is a human readable description for the artifact.
     * @type {string}
     * @memberof V1FlavorArtifact
     */
    'Description'?: string;
    /**
     * Tags is a set of artifact tags.
     * @type {{ [key: string]: object; }}
     * @memberof V1FlavorArtifact
     */
    'Tags'?: { [key: string]: object; };
}
/**
 * FlavorListResponse represents details about the available cluster flavors.
 * @export
 * @interface V1FlavorListResponse
 */
export interface V1FlavorListResponse {
    /**
     * Default is the flavor ID of the default cluster flavor.
     * @type {string}
     * @memberof V1FlavorListResponse
     */
    'Default'?: string;
    /**
     * Flavors is a list of all available cluster flavors.
     * @type {Array<V1Flavor>}
     * @memberof V1FlavorListResponse
     */
    'Flavors'?: Array<V1Flavor>;
}
/**
 * 
 * @export
 * @interface V1InfraStatus
 */
export interface V1InfraStatus {
    /**
     * MaintenanceActive is an indicator whether a maintenance is ongoing.
     * @type {boolean}
     * @memberof V1InfraStatus
     */
    'MaintenanceActive'?: boolean;
    /**
     * Maintainer is the email of the person currently doing maintenance.
     * @type {string}
     * @memberof V1InfraStatus
     */
    'Maintainer'?: string;
}
/**
 * Log represents the logs from a specific pod.
 * @export
 * @interface V1Log
 */
export interface V1Log {
    /**
     * Name is the name given to this pod in the workflow.
     * @type {string}
     * @memberof V1Log
     */
    'Name'?: string;
    /**
     * Started is the time at which this pod was started. Used for ordering between pods.
     * @type {string}
     * @memberof V1Log
     */
    'Started'?: string;
    /**
     * Body is the raw pod logs.
     * @type {string}
     * @memberof V1Log
     */
    'Body'?: string;
    /**
     * Message surfaces step state from Argo.
     * @type {string}
     * @memberof V1Log
     */
    'Message'?: string;
}
/**
 * LogsResponse represents a collection of logs.
 * @export
 * @interface V1LogsResponse
 */
export interface V1LogsResponse {
    /**
     * Logs are all of the logs from a cluster.
     * @type {Array<V1Log>}
     * @memberof V1LogsResponse
     */
    'Logs'?: Array<V1Log>;
}
/**
 * Parameter represents a single parameter that is needed to launch a flavor.
 * @export
 * @interface V1Parameter
 */
export interface V1Parameter {
    /**
     * Name is the unique name of the parameter.
     * @type {string}
     * @memberof V1Parameter
     */
    'Name'?: string;
    /**
     * Description is a human readable description for the parameter.
     * @type {string}
     * @memberof V1Parameter
     */
    'Description'?: string;
    /**
     * Value that this parameter could have. If the parameter is not optional, then value serves as an example. If the parameter is optional, then value serves as a default. If the parameter is internal, then value serves as a hardcoded constant.
     * @type {string}
     * @memberof V1Parameter
     */
    'Value'?: string;
    /**
     * Optional indicates that this parameter can be optionally provided by a user. If the user does not provide a value, then Value serves as a default.
     * @type {boolean}
     * @memberof V1Parameter
     */
    'Optional'?: boolean;
    /**
     * Internal indicates that this parameter should not be provided by a user, but rather treats Value as a hardcoded constant.
     * @type {boolean}
     * @memberof V1Parameter
     */
    'Internal'?: boolean;
    /**
     * The relative order of importance of this parameter for when presenting in a UI for example.
     * @type {number}
     * @memberof V1Parameter
     */
    'Order'?: number;
    /**
     * 
     * @type {string}
     * @memberof V1Parameter
     */
    'Help'?: string;
    /**
     * Indicates that the value for this parameter can be provided from the contents of a file.
     * @type {boolean}
     * @memberof V1Parameter
     */
    'FromFile'?: boolean;
}
/**
 * ResourceByID represents a generic reference to a named/unique resource.
 * @export
 * @interface V1ResourceByID
 */
export interface V1ResourceByID {
    /**
     * 
     * @type {string}
     * @memberof V1ResourceByID
     */
    'id'?: string;
}
/**
 * ServiceAccount represents an authenticated service account (robot) principal.
 * @export
 * @interface V1ServiceAccount
 */
export interface V1ServiceAccount {
    /**
     * Name is a human readable name for the service account.
     * @type {string}
     * @memberof V1ServiceAccount
     */
    'Name'?: string;
    /**
     * Description is a human readable description for the service account.
     * @type {string}
     * @memberof V1ServiceAccount
     */
    'Description'?: string;
    /**
     * Email is the Red Hat email address for the service account.
     * @type {string}
     * @memberof V1ServiceAccount
     */
    'Email'?: string;
    /**
     * IssuedAt is the time of issuing the service account token.
     * @type {string}
     * @memberof V1ServiceAccount
     */
    'IssuedAt'?: string;
    /**
     * NotBefore is the beginning of service account token valid time period.
     * @type {string}
     * @memberof V1ServiceAccount
     */
    'NotBefore'?: string;
    /**
     * ExpiresAt is the end of service account token valid time period.
     * @type {string}
     * @memberof V1ServiceAccount
     */
    'ExpiresAt'?: string;
}
/**
 * 
 * @export
 * @interface V1TokenResponse
 */
export interface V1TokenResponse {
    /**
     * 
     * @type {V1ServiceAccount}
     * @memberof V1TokenResponse
     */
    'Account'?: V1ServiceAccount;
    /**
     * Token is the token generated for the service account.
     * @type {string}
     * @memberof V1TokenResponse
     */
    'Token'?: string;
}
/**
 * User represents an authenticated (human) principal.
 * @export
 * @interface V1User
 */
export interface V1User {
    /**
     * Expiry is the expiration date of this user session. Used only as a hint to the user and not for enforcement.
     * @type {string}
     * @memberof V1User
     */
    'Expiry'?: string;
    /**
     * Name is the full name of the user.
     * @type {string}
     * @memberof V1User
     */
    'Name'?: string;
    /**
     * Email is the email address of the user.
     * @type {string}
     * @memberof V1User
     */
    'Email'?: string;
    /**
     * Picture is a URL linking to this user\'s profile picture, if available.
     * @type {string}
     * @memberof V1User
     */
    'Picture'?: string;
}
/**
 * 
 * @export
 * @interface V1Version
 */
export interface V1Version {
    /**
     * 
     * @type {string}
     * @memberof V1Version
     */
    'BuildDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Version
     */
    'GitCommit'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Version
     */
    'GoVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Version
     */
    'Platform'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Version
     */
    'Version'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Version
     */
    'Workflow'?: string;
}
/**
 * WhoamiResponse represents details about the current authenticated principal.
 * @export
 * @interface V1WhoamiResponse
 */
export interface V1WhoamiResponse {
    /**
     * 
     * @type {V1User}
     * @memberof V1WhoamiResponse
     */
    'User'?: V1User;
    /**
     * 
     * @type {V1ServiceAccount}
     * @memberof V1WhoamiResponse
     */
    'ServiceAccount'?: V1ServiceAccount;
}

/**
 * CliServiceApi - axios parameter creator
 * @export
 */
export const CliServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upgrade - gets an updated binary if it exists.
         * @param {string} os 
         * @param {string} arch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cliServiceUpgrade: async (os: string, arch: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'os' is not null or undefined
            assertParamExists('cliServiceUpgrade', 'os', os)
            // verify required parameter 'arch' is not null or undefined
            assertParamExists('cliServiceUpgrade', 'arch', arch)
            const localVarPath = `/v1/cli/{os}/{arch}/upgrade`
                .replace(`{${"os"}}`, encodeURIComponent(String(os)))
                .replace(`{${"arch"}}`, encodeURIComponent(String(arch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CliServiceApi - functional programming interface
 * @export
 */
export const CliServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CliServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Upgrade - gets an updated binary if it exists.
         * @param {string} os 
         * @param {string} arch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cliServiceUpgrade(os: string, arch: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamResultOfV1CliUpgradeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cliServiceUpgrade(os, arch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CliServiceApi - factory interface
 * @export
 */
export const CliServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CliServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Upgrade - gets an updated binary if it exists.
         * @param {string} os 
         * @param {string} arch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cliServiceUpgrade(os: string, arch: string, options?: any): AxiosPromise<StreamResultOfV1CliUpgradeResponse> {
            return localVarFp.cliServiceUpgrade(os, arch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CliServiceApi - object-oriented interface
 * @export
 * @class CliServiceApi
 * @extends {BaseAPI}
 */
export class CliServiceApi extends BaseAPI {
    /**
     * 
     * @summary Upgrade - gets an updated binary if it exists.
     * @param {string} os 
     * @param {string} arch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CliServiceApi
     */
    public cliServiceUpgrade(os: string, arch: string, options?: AxiosRequestConfig) {
        return CliServiceApiFp(this.configuration).cliServiceUpgrade(os, arch, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClusterServiceApi - axios parameter creator
 * @export
 */
export const ClusterServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Artifacts returns the artifacts for a specific cluster.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterServiceArtifacts: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clusterServiceArtifacts', 'id', id)
            const localVarPath = `/v1/cluster/{id}/artifacts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create launches a new cluster.
         * @param {V1CreateClusterRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterServiceCreate: async (body: V1CreateClusterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('clusterServiceCreate', 'body', body)
            const localVarPath = `/v1/cluster`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete deletes an existing cluster.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterServiceDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clusterServiceDelete', 'id', id)
            const localVarPath = `/v1/cluster/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Info provides information about a specific cluster.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterServiceInfo: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clusterServiceInfo', 'id', id)
            const localVarPath = `/v1/cluster/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lifespan updates the lifespan for a specific cluster.
         * @param {string} id ID is the unique ID for the cluster.
         * @param {ClusterServiceLifespanRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterServiceLifespan: async (id: string, body: ClusterServiceLifespanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clusterServiceLifespan', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('clusterServiceLifespan', 'body', body)
            const localVarPath = `/v1/cluster/{id}/lifespan`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List provides information about the available clusters.
         * @param {boolean} [all] all indicates that all clusters should be returned, not just the ones owned by the user.
         * @param {boolean} [expired] expired indicates that expired clusters should be returned, not just the ones that are launching/ready.
         * @param {string} [prefix] list clusters whose ID matches this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterServiceList: async (all?: boolean, expired?: boolean, prefix?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cluster`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }

            if (expired !== undefined) {
                localVarQueryParameter['expired'] = expired;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs returns the logs for a specific cluster.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterServiceLogs: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clusterServiceLogs', 'id', id)
            const localVarPath = `/v1/cluster/{id}/logs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClusterServiceApi - functional programming interface
 * @export
 */
export const ClusterServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClusterServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Artifacts returns the artifacts for a specific cluster.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterServiceArtifacts(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ClusterArtifacts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterServiceArtifacts(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create launches a new cluster.
         * @param {V1CreateClusterRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterServiceCreate(body: V1CreateClusterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ResourceByID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterServiceCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete deletes an existing cluster.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterServiceDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterServiceDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Info provides information about a specific cluster.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterServiceInfo(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterServiceInfo(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lifespan updates the lifespan for a specific cluster.
         * @param {string} id ID is the unique ID for the cluster.
         * @param {ClusterServiceLifespanRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterServiceLifespan(id: string, body: ClusterServiceLifespanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterServiceLifespan(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List provides information about the available clusters.
         * @param {boolean} [all] all indicates that all clusters should be returned, not just the ones owned by the user.
         * @param {boolean} [expired] expired indicates that expired clusters should be returned, not just the ones that are launching/ready.
         * @param {string} [prefix] list clusters whose ID matches this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterServiceList(all?: boolean, expired?: boolean, prefix?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ClusterListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterServiceList(all, expired, prefix, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logs returns the logs for a specific cluster.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterServiceLogs(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1LogsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterServiceLogs(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClusterServiceApi - factory interface
 * @export
 */
export const ClusterServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClusterServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Artifacts returns the artifacts for a specific cluster.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterServiceArtifacts(id: string, options?: any): AxiosPromise<V1ClusterArtifacts> {
            return localVarFp.clusterServiceArtifacts(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create launches a new cluster.
         * @param {V1CreateClusterRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterServiceCreate(body: V1CreateClusterRequest, options?: any): AxiosPromise<V1ResourceByID> {
            return localVarFp.clusterServiceCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete deletes an existing cluster.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterServiceDelete(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.clusterServiceDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Info provides information about a specific cluster.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterServiceInfo(id: string, options?: any): AxiosPromise<V1Cluster> {
            return localVarFp.clusterServiceInfo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lifespan updates the lifespan for a specific cluster.
         * @param {string} id ID is the unique ID for the cluster.
         * @param {ClusterServiceLifespanRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterServiceLifespan(id: string, body: ClusterServiceLifespanRequest, options?: any): AxiosPromise<string> {
            return localVarFp.clusterServiceLifespan(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List provides information about the available clusters.
         * @param {boolean} [all] all indicates that all clusters should be returned, not just the ones owned by the user.
         * @param {boolean} [expired] expired indicates that expired clusters should be returned, not just the ones that are launching/ready.
         * @param {string} [prefix] list clusters whose ID matches this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterServiceList(all?: boolean, expired?: boolean, prefix?: string, options?: any): AxiosPromise<V1ClusterListResponse> {
            return localVarFp.clusterServiceList(all, expired, prefix, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logs returns the logs for a specific cluster.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterServiceLogs(id: string, options?: any): AxiosPromise<V1LogsResponse> {
            return localVarFp.clusterServiceLogs(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClusterServiceApi - object-oriented interface
 * @export
 * @class ClusterServiceApi
 * @extends {BaseAPI}
 */
export class ClusterServiceApi extends BaseAPI {
    /**
     * 
     * @summary Artifacts returns the artifacts for a specific cluster.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterServiceApi
     */
    public clusterServiceArtifacts(id: string, options?: AxiosRequestConfig) {
        return ClusterServiceApiFp(this.configuration).clusterServiceArtifacts(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create launches a new cluster.
     * @param {V1CreateClusterRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterServiceApi
     */
    public clusterServiceCreate(body: V1CreateClusterRequest, options?: AxiosRequestConfig) {
        return ClusterServiceApiFp(this.configuration).clusterServiceCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete deletes an existing cluster.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterServiceApi
     */
    public clusterServiceDelete(id: string, options?: AxiosRequestConfig) {
        return ClusterServiceApiFp(this.configuration).clusterServiceDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Info provides information about a specific cluster.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterServiceApi
     */
    public clusterServiceInfo(id: string, options?: AxiosRequestConfig) {
        return ClusterServiceApiFp(this.configuration).clusterServiceInfo(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lifespan updates the lifespan for a specific cluster.
     * @param {string} id ID is the unique ID for the cluster.
     * @param {ClusterServiceLifespanRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterServiceApi
     */
    public clusterServiceLifespan(id: string, body: ClusterServiceLifespanRequest, options?: AxiosRequestConfig) {
        return ClusterServiceApiFp(this.configuration).clusterServiceLifespan(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List provides information about the available clusters.
     * @param {boolean} [all] all indicates that all clusters should be returned, not just the ones owned by the user.
     * @param {boolean} [expired] expired indicates that expired clusters should be returned, not just the ones that are launching/ready.
     * @param {string} [prefix] list clusters whose ID matches this prefix.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterServiceApi
     */
    public clusterServiceList(all?: boolean, expired?: boolean, prefix?: string, options?: AxiosRequestConfig) {
        return ClusterServiceApiFp(this.configuration).clusterServiceList(all, expired, prefix, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logs returns the logs for a specific cluster.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterServiceApi
     */
    public clusterServiceLogs(id: string, options?: AxiosRequestConfig) {
        return ClusterServiceApiFp(this.configuration).clusterServiceLogs(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FlavorServiceApi - axios parameter creator
 * @export
 */
export const FlavorServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Info provides information about a specific flavor.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorServiceInfo: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flavorServiceInfo', 'id', id)
            const localVarPath = `/v1/flavor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List provides information about the available flavors.
         * @param {boolean} [all] all indicates that all flavors should be returned, by default availability alpha clusters are excluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorServiceList: async (all?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/flavor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlavorServiceApi - functional programming interface
 * @export
 */
export const FlavorServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlavorServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Info provides information about a specific flavor.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorServiceInfo(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Flavor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorServiceInfo(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List provides information about the available flavors.
         * @param {boolean} [all] all indicates that all flavors should be returned, by default availability alpha clusters are excluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorServiceList(all?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1FlavorListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorServiceList(all, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FlavorServiceApi - factory interface
 * @export
 */
export const FlavorServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlavorServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Info provides information about a specific flavor.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorServiceInfo(id: string, options?: any): AxiosPromise<V1Flavor> {
            return localVarFp.flavorServiceInfo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List provides information about the available flavors.
         * @param {boolean} [all] all indicates that all flavors should be returned, by default availability alpha clusters are excluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorServiceList(all?: boolean, options?: any): AxiosPromise<V1FlavorListResponse> {
            return localVarFp.flavorServiceList(all, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlavorServiceApi - object-oriented interface
 * @export
 * @class FlavorServiceApi
 * @extends {BaseAPI}
 */
export class FlavorServiceApi extends BaseAPI {
    /**
     * 
     * @summary Info provides information about a specific flavor.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorServiceApi
     */
    public flavorServiceInfo(id: string, options?: AxiosRequestConfig) {
        return FlavorServiceApiFp(this.configuration).flavorServiceInfo(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List provides information about the available flavors.
     * @param {boolean} [all] all indicates that all flavors should be returned, by default availability alpha clusters are excluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorServiceApi
     */
    public flavorServiceList(all?: boolean, options?: AxiosRequestConfig) {
        return FlavorServiceApiFp(this.configuration).flavorServiceList(all, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InfraStatusServiceApi - axios parameter creator
 * @export
 */
export const InfraStatusServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary GetStatus gets the maintenance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infraStatusServiceGetStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ResetStatus resets the maintenance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infraStatusServiceResetStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary SetStatus sets the maintenance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infraStatusServiceSetStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfraStatusServiceApi - functional programming interface
 * @export
 */
export const InfraStatusServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfraStatusServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary GetStatus gets the maintenance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infraStatusServiceGetStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1InfraStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infraStatusServiceGetStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ResetStatus resets the maintenance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infraStatusServiceResetStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1InfraStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infraStatusServiceResetStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary SetStatus sets the maintenance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infraStatusServiceSetStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1InfraStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infraStatusServiceSetStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InfraStatusServiceApi - factory interface
 * @export
 */
export const InfraStatusServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfraStatusServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary GetStatus gets the maintenance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infraStatusServiceGetStatus(options?: any): AxiosPromise<V1InfraStatus> {
            return localVarFp.infraStatusServiceGetStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ResetStatus resets the maintenance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infraStatusServiceResetStatus(options?: any): AxiosPromise<V1InfraStatus> {
            return localVarFp.infraStatusServiceResetStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary SetStatus sets the maintenance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infraStatusServiceSetStatus(options?: any): AxiosPromise<V1InfraStatus> {
            return localVarFp.infraStatusServiceSetStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfraStatusServiceApi - object-oriented interface
 * @export
 * @class InfraStatusServiceApi
 * @extends {BaseAPI}
 */
export class InfraStatusServiceApi extends BaseAPI {
    /**
     * 
     * @summary GetStatus gets the maintenance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfraStatusServiceApi
     */
    public infraStatusServiceGetStatus(options?: AxiosRequestConfig) {
        return InfraStatusServiceApiFp(this.configuration).infraStatusServiceGetStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ResetStatus resets the maintenance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfraStatusServiceApi
     */
    public infraStatusServiceResetStatus(options?: AxiosRequestConfig) {
        return InfraStatusServiceApiFp(this.configuration).infraStatusServiceResetStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary SetStatus sets the maintenance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfraStatusServiceApi
     */
    public infraStatusServiceSetStatus(options?: AxiosRequestConfig) {
        return InfraStatusServiceApiFp(this.configuration).infraStatusServiceSetStatus(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserServiceApi - axios parameter creator
 * @export
 */
export const UserServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary CreateToken generates an arbitrary service account token
         * @param {V1ServiceAccount} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceCreateToken: async (body: V1ServiceAccount, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userServiceCreateToken', 'body', body)
            const localVarPath = `/v1/token-create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Token generates a service account token for the current user.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceToken: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userServiceToken', 'body', body)
            const localVarPath = `/v1/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Whoami provides information about the currently authenticated principal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceWhoami: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserServiceApi - functional programming interface
 * @export
 */
export const UserServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary CreateToken generates an arbitrary service account token
         * @param {V1ServiceAccount} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userServiceCreateToken(body: V1ServiceAccount, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userServiceCreateToken(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Token generates a service account token for the current user.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userServiceToken(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userServiceToken(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Whoami provides information about the currently authenticated principal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userServiceWhoami(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1WhoamiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userServiceWhoami(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserServiceApi - factory interface
 * @export
 */
export const UserServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary CreateToken generates an arbitrary service account token
         * @param {V1ServiceAccount} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceCreateToken(body: V1ServiceAccount, options?: any): AxiosPromise<V1TokenResponse> {
            return localVarFp.userServiceCreateToken(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Token generates a service account token for the current user.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceToken(body: object, options?: any): AxiosPromise<V1TokenResponse> {
            return localVarFp.userServiceToken(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Whoami provides information about the currently authenticated principal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceWhoami(options?: any): AxiosPromise<V1WhoamiResponse> {
            return localVarFp.userServiceWhoami(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserServiceApi - object-oriented interface
 * @export
 * @class UserServiceApi
 * @extends {BaseAPI}
 */
export class UserServiceApi extends BaseAPI {
    /**
     * 
     * @summary CreateToken generates an arbitrary service account token
     * @param {V1ServiceAccount} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public userServiceCreateToken(body: V1ServiceAccount, options?: AxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).userServiceCreateToken(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Token generates a service account token for the current user.
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public userServiceToken(body: object, options?: AxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).userServiceToken(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Whoami provides information about the currently authenticated principal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public userServiceWhoami(options?: AxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).userServiceWhoami(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VersionServiceApi - axios parameter creator
 * @export
 */
export const VersionServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionServiceGetVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionServiceApi - functional programming interface
 * @export
 */
export const VersionServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async versionServiceGetVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Version>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.versionServiceGetVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VersionServiceApi - factory interface
 * @export
 */
export const VersionServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionServiceGetVersion(options?: any): AxiosPromise<V1Version> {
            return localVarFp.versionServiceGetVersion(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionServiceApi - object-oriented interface
 * @export
 * @class VersionServiceApi
 * @extends {BaseAPI}
 */
export class VersionServiceApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionServiceApi
     */
    public versionServiceGetVersion(options?: AxiosRequestConfig) {
        return VersionServiceApiFp(this.configuration).versionServiceGetVersion(options).then((request) => request(this.axios, this.basePath));
    }
}


