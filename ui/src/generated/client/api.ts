/* tslint:disable */
/* eslint-disable */
/**
 * proto/api/v1/service.proto
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Status represents the various cluster states.   - FAILED: FAILED is the state when the cluster has failed in one way or another.  - CREATING: CREATING is the state when the cluster is being created.  - READY: READY is the state when the cluster is available and ready for use.  - DESTROYING: DESTROYING is the state when the cluster is being destroyed.  - FINISHED: FINISHED is the state when the cluster has been successfully destroyed.
 * @export
 * @enum {string}
 */
export enum Apiv1Status {
  Failed = 'FAILED',
  Creating = 'CREATING',
  Ready = 'READY',
  Destroying = 'DESTROYING',
  Finished = 'FINISHED',
}

/**
 * availability represents the availability classification levels.   - alpha: alpha is completely experemental, and is not expected to work in any way.  - beta: beta is being tested, and is expected to work with minor issues.  - stable: stable is available for public consumption, and works without issue.  - default: default is stable, and available for customer demo consumption. Exactly 1 flavor should be configured as default.
 * @export
 * @enum {string}
 */
export enum Flavoravailability {
  Alpha = 'alpha',
  Beta = 'beta',
  Stable = 'stable',
  Default = 'default',
}

/**
 *
 * @export
 * @interface GooglerpcStatus
 */
export interface GooglerpcStatus {
  /**
   *
   * @type {number}
   * @memberof GooglerpcStatus
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof GooglerpcStatus
   */
  message?: string;
  /**
   *
   * @type {Array<ProtobufAny>}
   * @memberof GooglerpcStatus
   */
  details?: Array<ProtobufAny>;
}
/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
  /**
   * Lifespan is the new lifespan.
   * @type {string}
   * @memberof InlineObject
   */
  Lifespan?: string;
  /**
   *
   * @type {LifespanRequestMethod}
   * @memberof InlineObject
   */
  method?: LifespanRequestMethod;
}
/**
 * method represents the various lifespan operations.   - REPLACE: REPLACE indicates that the given lifespan should replace the current lifespan.  - ADD: ADD indicates that the given lifespan should be added to the current lifespan.  - SUBTRACT: SUBTRACT indicates that the given lifespan should be subtracted from the current lifespan.
 * @export
 * @enum {string}
 */
export enum LifespanRequestMethod {
  Replace = 'REPLACE',
  Add = 'ADD',
  Subtract = 'SUBTRACT',
}

/**
 *
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
  [key: string]: object | any;

  /**
   *
   * @type {string}
   * @memberof ProtobufAny
   */
  type?: string;
}
/**
 *
 * @export
 * @interface StreamResultOfV1CliUpgradeResponse
 */
export interface StreamResultOfV1CliUpgradeResponse {
  /**
   *
   * @type {V1CliUpgradeResponse}
   * @memberof StreamResultOfV1CliUpgradeResponse
   */
  result?: V1CliUpgradeResponse;
  /**
   *
   * @type {GooglerpcStatus}
   * @memberof StreamResultOfV1CliUpgradeResponse
   */
  error?: GooglerpcStatus;
}
/**
 *
 * @export
 * @interface V1Artifact
 */
export interface V1Artifact {
  /**
   *
   * @type {string}
   * @memberof V1Artifact
   */
  Name?: string;
  /**
   *
   * @type {string}
   * @memberof V1Artifact
   */
  Description?: string;
  /**
   *
   * @type {string}
   * @memberof V1Artifact
   */
  URL?: string;
  /**
   *
   * @type {number}
   * @memberof V1Artifact
   */
  Mode?: number;
}
/**
 *
 * @export
 * @interface V1CliUpgradeResponse
 */
export interface V1CliUpgradeResponse {
  /**
   *
   * @type {string}
   * @memberof V1CliUpgradeResponse
   */
  fileChunk?: string;
}
/**
 * Cluster represents a single cluster.
 * @export
 * @interface V1Cluster
 */
export interface V1Cluster {
  /**
   * ID is the unique ID for the cluster.
   * @type {string}
   * @memberof V1Cluster
   */
  ID?: string;
  /**
   *
   * @type {Apiv1Status}
   * @memberof V1Cluster
   */
  Status?: Apiv1Status;
  /**
   * Flavor is the original flavor ID that launched this cluster.
   * @type {string}
   * @memberof V1Cluster
   */
  Flavor?: string;
  /**
   * Owner is the email address for the cluster owner.
   * @type {string}
   * @memberof V1Cluster
   */
  Owner?: string;
  /**
   * CreatedOn is the timestamp on which the cluster started being created.
   * @type {string}
   * @memberof V1Cluster
   */
  CreatedOn?: string;
  /**
   * DestroyedOn is the timestamp on which the cluster finished being destroyed.
   * @type {string}
   * @memberof V1Cluster
   */
  DestroyedOn?: string;
  /**
   * Lifespan is the duration for which the cluster should be kept alive.
   * @type {string}
   * @memberof V1Cluster
   */
  Lifespan?: string;
  /**
   * Description is a human readable description for the cluster.
   * @type {string}
   * @memberof V1Cluster
   */
  Description?: string;
  /**
   * URL is an optional URL for this cluster.
   * @type {string}
   * @memberof V1Cluster
   */
  URL?: string;
  /**
   * Connect is a command to add kube connection information to kubeconfig.
   * @type {string}
   * @memberof V1Cluster
   */
  Connect?: string;
}
/**
 *
 * @export
 * @interface V1ClusterArtifacts
 */
export interface V1ClusterArtifacts {
  /**
   *
   * @type {Array<V1Artifact>}
   * @memberof V1ClusterArtifacts
   */
  Artifacts?: Array<V1Artifact>;
}
/**
 * ClusterListResponse represents details about all clusters.
 * @export
 * @interface V1ClusterListResponse
 */
export interface V1ClusterListResponse {
  /**
   * Clusters is a list of all clusters.
   * @type {Array<V1Cluster>}
   * @memberof V1ClusterListResponse
   */
  Clusters?: Array<V1Cluster>;
}
/**
 * CreateClusterRequest represents details for launching a new cluster.
 * @export
 * @interface V1CreateClusterRequest
 */
export interface V1CreateClusterRequest {
  /**
   * ID is the flavor ID to launch.
   * @type {string}
   * @memberof V1CreateClusterRequest
   */
  ID?: string;
  /**
   * Lifespan is the initial cluster lifespan.
   * @type {string}
   * @memberof V1CreateClusterRequest
   */
  Lifespan?: string;
  /**
   * Parameters is a map of launch parameter names to values.
   * @type {{ [key: string]: string; }}
   * @memberof V1CreateClusterRequest
   */
  Parameters?: { [key: string]: string };
  /**
   * Description is a human readable description for the cluster.
   * @type {string}
   * @memberof V1CreateClusterRequest
   */
  Description?: string;
  /**
   * NoSlack is used to skip sending Slack messages for cluster lifecycle events.
   * @type {boolean}
   * @memberof V1CreateClusterRequest
   */
  NoSlack?: boolean;
  /**
   * SlackDM is used to choose direct messages for cluster lifecycle events.
   * @type {boolean}
   * @memberof V1CreateClusterRequest
   */
  SlackDM?: boolean;
}
/**
 * Flavor represents a configured cluster flavor.
 * @export
 * @interface V1Flavor
 */
export interface V1Flavor {
  /**
   * ID is the unique, human type-able, ID for the flavor.
   * @type {string}
   * @memberof V1Flavor
   */
  ID?: string;
  /**
   * Name is a human readable name for the flavor.
   * @type {string}
   * @memberof V1Flavor
   */
  Name?: string;
  /**
   * Description is a human readable description for the flavor.
   * @type {string}
   * @memberof V1Flavor
   */
  Description?: string;
  /**
   *
   * @type {Flavoravailability}
   * @memberof V1Flavor
   */
  Availability?: Flavoravailability;
  /**
   * Parameters is a map of parameters required for launching this flavor.
   * @type {{ [key: string]: V1Parameter; }}
   * @memberof V1Flavor
   */
  Parameters?: { [key: string]: V1Parameter };
  /**
   * Artifacts is a map of artifacts produced by this flavor.
   * @type {{ [key: string]: V1FlavorArtifact; }}
   * @memberof V1Flavor
   */
  Artifacts?: { [key: string]: V1FlavorArtifact };
}
/**
 * FlavorArtifact represents a single artifact that is produced by a flavor.
 * @export
 * @interface V1FlavorArtifact
 */
export interface V1FlavorArtifact {
  /**
   * Name is the unique name of the artifact.
   * @type {string}
   * @memberof V1FlavorArtifact
   */
  Name?: string;
  /**
   * Description is a human readable description for the artifact.
   * @type {string}
   * @memberof V1FlavorArtifact
   */
  Description?: string;
  /**
   * Tags is a set of artifact tags.
   * @type {{ [key: string]: object; }}
   * @memberof V1FlavorArtifact
   */
  Tags?: { [key: string]: object };
}
/**
 * FlavorListResponse represents details about the available cluster flavors.
 * @export
 * @interface V1FlavorListResponse
 */
export interface V1FlavorListResponse {
  /**
   * Default is the flavor ID of the default cluster flavor.
   * @type {string}
   * @memberof V1FlavorListResponse
   */
  Default?: string;
  /**
   * Flavors is a list of all available cluster flavors.
   * @type {Array<V1Flavor>}
   * @memberof V1FlavorListResponse
   */
  Flavors?: Array<V1Flavor>;
}
/**
 *
 * @export
 * @interface V1InfraStatus
 */
export interface V1InfraStatus {
  /**
   * MaintenanceActive is an indicator whether a maintenance is ongoing.
   * @type {boolean}
   * @memberof V1InfraStatus
   */
  MaintenanceActive?: boolean;
  /**
   * Maintainer is the email of the person currently doing maintenance.
   * @type {string}
   * @memberof V1InfraStatus
   */
  Maintainer?: string;
}
/**
 * Log represents the logs from a specific pod.
 * @export
 * @interface V1Log
 */
export interface V1Log {
  /**
   * Name is the name given to this pod in the workflow.
   * @type {string}
   * @memberof V1Log
   */
  Name?: string;
  /**
   * Started is the time at which this pod was started. Used for ordering between pods.
   * @type {string}
   * @memberof V1Log
   */
  Started?: string;
  /**
   * Body is the raw pod logs.
   * @type {string}
   * @memberof V1Log
   */
  Body?: string;
  /**
   * Message surfaces step state from Argo.
   * @type {string}
   * @memberof V1Log
   */
  Message?: string;
}
/**
 * LogsResponse represents a collection of logs.
 * @export
 * @interface V1LogsResponse
 */
export interface V1LogsResponse {
  /**
   * Logs are all of the logs from a cluster.
   * @type {Array<V1Log>}
   * @memberof V1LogsResponse
   */
  Logs?: Array<V1Log>;
}
/**
 * Parameter represents a single parameter that is needed to launch a flavor.
 * @export
 * @interface V1Parameter
 */
export interface V1Parameter {
  /**
   * Name is the unique name of the parameter.
   * @type {string}
   * @memberof V1Parameter
   */
  Name?: string;
  /**
   * Description is a human readable description for the parameter.
   * @type {string}
   * @memberof V1Parameter
   */
  Description?: string;
  /**
   * Value that this parameter could have. If the parameter is not optional, then value serves as an example. If the parameter is optional, then value serves as a default. If the parameter is internal, then value serves as a hardcoded constant.
   * @type {string}
   * @memberof V1Parameter
   */
  Value?: string;
  /**
   * Optional indicates that this parameter can be optionally provided by a user. If the user does not provide a value, then Value serves as a default.
   * @type {boolean}
   * @memberof V1Parameter
   */
  Optional?: boolean;
  /**
   * Internal indicates that this parameter should not be provided by a user, but rather treats Value as a hardcoded constant.
   * @type {boolean}
   * @memberof V1Parameter
   */
  Internal?: boolean;
  /**
   * The relative order of importance of this parameter for when presenting in a UI for example.
   * @type {number}
   * @memberof V1Parameter
   */
  Order?: number;
  /**
   *
   * @type {string}
   * @memberof V1Parameter
   */
  Help?: string;
  /**
   * Indicates that the value for this parameter can be provided from the contents of a file.
   * @type {boolean}
   * @memberof V1Parameter
   */
  FromFile?: boolean;
}
/**
 * ResourceByID represents a generic reference to a named/unique resource.
 * @export
 * @interface V1ResourceByID
 */
export interface V1ResourceByID {
  /**
   *
   * @type {string}
   * @memberof V1ResourceByID
   */
  id?: string;
}
/**
 * ServiceAccount represents an authenticated service account (robot) principal.
 * @export
 * @interface V1ServiceAccount
 */
export interface V1ServiceAccount {
  /**
   * Name is a human readable name for the service account.
   * @type {string}
   * @memberof V1ServiceAccount
   */
  Name?: string;
  /**
   * Description is a human readable description for the service account.
   * @type {string}
   * @memberof V1ServiceAccount
   */
  Description?: string;
  /**
   * Email is the Red Hat email address for the service account.
   * @type {string}
   * @memberof V1ServiceAccount
   */
  Email?: string;
  /**
   * IssuedAt is the time of issuing the service account token.
   * @type {string}
   * @memberof V1ServiceAccount
   */
  IssuedAt?: string;
  /**
   * NotBefore is the beginning of service account token valid time period.
   * @type {string}
   * @memberof V1ServiceAccount
   */
  NotBefore?: string;
  /**
   * ExpiresAt is the end of service account token valid time period.
   * @type {string}
   * @memberof V1ServiceAccount
   */
  ExpiresAt?: string;
}
/**
 *
 * @export
 * @interface V1TokenResponse
 */
export interface V1TokenResponse {
  /**
   *
   * @type {V1ServiceAccount}
   * @memberof V1TokenResponse
   */
  Account?: V1ServiceAccount;
  /**
   * Token is the token generated for the service account.
   * @type {string}
   * @memberof V1TokenResponse
   */
  Token?: string;
}
/**
 * User represents an authenticated (human) principal.
 * @export
 * @interface V1User
 */
export interface V1User {
  /**
   * Expiry is the expiration date of this user session. Used only as a hint to the user and not for enforcement.
   * @type {string}
   * @memberof V1User
   */
  Expiry?: string;
  /**
   * Name is the full name of the user.
   * @type {string}
   * @memberof V1User
   */
  Name?: string;
  /**
   * Email is the email address of the user.
   * @type {string}
   * @memberof V1User
   */
  Email?: string;
  /**
   * Picture is a URL linking to this user\'s profile picture, if available.
   * @type {string}
   * @memberof V1User
   */
  Picture?: string;
}
/**
 *
 * @export
 * @interface V1Version
 */
export interface V1Version {
  /**
   *
   * @type {string}
   * @memberof V1Version
   */
  BuildDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1Version
   */
  GitCommit?: string;
  /**
   *
   * @type {string}
   * @memberof V1Version
   */
  GoVersion?: string;
  /**
   *
   * @type {string}
   * @memberof V1Version
   */
  Platform?: string;
  /**
   *
   * @type {string}
   * @memberof V1Version
   */
  Version?: string;
  /**
   *
   * @type {string}
   * @memberof V1Version
   */
  Workflow?: string;
}
/**
 * WhoamiResponse represents details about the current authenticated principal.
 * @export
 * @interface V1WhoamiResponse
 */
export interface V1WhoamiResponse {
  /**
   *
   * @type {V1User}
   * @memberof V1WhoamiResponse
   */
  User?: V1User;
  /**
   *
   * @type {V1ServiceAccount}
   * @memberof V1WhoamiResponse
   */
  ServiceAccount?: V1ServiceAccount;
}

/**
 * CliServiceApi - axios parameter creator
 * @export
 */
export const CliServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Upgrade - gets an updated binary if it exists.
     * @param {string} os
     * @param {string} arch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cliServiceUpgrade: async (
      os: string,
      arch: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'os' is not null or undefined
      if (os === null || os === undefined) {
        throw new RequiredError(
          'os',
          'Required parameter os was null or undefined when calling cliServiceUpgrade.'
        );
      }
      // verify required parameter 'arch' is not null or undefined
      if (arch === null || arch === undefined) {
        throw new RequiredError(
          'arch',
          'Required parameter arch was null or undefined when calling cliServiceUpgrade.'
        );
      }
      const localVarPath = `/v1/cli/{os}/{arch}/upgrade`
        .replace(`{${'os'}}`, encodeURIComponent(String(os)))
        .replace(`{${'arch'}}`, encodeURIComponent(String(arch)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CliServiceApi - functional programming interface
 * @export
 */
export const CliServiceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Upgrade - gets an updated binary if it exists.
     * @param {string} os
     * @param {string} arch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cliServiceUpgrade(
      os: string,
      arch: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamResultOfV1CliUpgradeResponse>
    > {
      const localVarAxiosArgs = await CliServiceApiAxiosParamCreator(
        configuration
      ).cliServiceUpgrade(os, arch, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * CliServiceApi - factory interface
 * @export
 */
export const CliServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Upgrade - gets an updated binary if it exists.
     * @param {string} os
     * @param {string} arch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cliServiceUpgrade(
      os: string,
      arch: string,
      options?: any
    ): AxiosPromise<StreamResultOfV1CliUpgradeResponse> {
      return CliServiceApiFp(configuration)
        .cliServiceUpgrade(os, arch, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CliServiceApi - object-oriented interface
 * @export
 * @class CliServiceApi
 * @extends {BaseAPI}
 */
export class CliServiceApi extends BaseAPI {
  /**
   *
   * @summary Upgrade - gets an updated binary if it exists.
   * @param {string} os
   * @param {string} arch
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CliServiceApi
   */
  public cliServiceUpgrade(os: string, arch: string, options?: any) {
    return CliServiceApiFp(this.configuration)
      .cliServiceUpgrade(os, arch, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ClusterServiceApi - axios parameter creator
 * @export
 */
export const ClusterServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Artifacts returns the artifacts for a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clusterServiceArtifacts: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling clusterServiceArtifacts.'
        );
      }
      const localVarPath = `/v1/cluster/{id}/artifacts`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create launches a new cluster.
     * @param {V1CreateClusterRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clusterServiceCreate: async (
      body: V1CreateClusterRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling clusterServiceCreate.'
        );
      }
      const localVarPath = `/v1/cluster`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof body !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete deletes an existing cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clusterServiceDelete: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling clusterServiceDelete.'
        );
      }
      const localVarPath = `/v1/cluster/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Info provides information about a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clusterServiceInfo: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling clusterServiceInfo.'
        );
      }
      const localVarPath = `/v1/cluster/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Lifespan updates the lifespan for a specific cluster.
     * @param {string} id ID is the unique ID for the cluster.
     * @param {InlineObject} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clusterServiceLifespan: async (
      id: string,
      body: InlineObject,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling clusterServiceLifespan.'
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling clusterServiceLifespan.'
        );
      }
      const localVarPath = `/v1/cluster/{id}/lifespan`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof body !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List provides information about the available clusters.
     * @param {boolean} [all] all indicates that all clusters should be returned, not just the ones owned by the user.
     * @param {boolean} [expired] expired indicates that expired clusters should be returned, not just the ones that are launching/ready.
     * @param {string} [prefix] list clusters whose ID matches this prefix.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clusterServiceList: async (
      all?: boolean,
      expired?: boolean,
      prefix?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/cluster`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (all !== undefined) {
        localVarQueryParameter['all'] = all;
      }

      if (expired !== undefined) {
        localVarQueryParameter['expired'] = expired;
      }

      if (prefix !== undefined) {
        localVarQueryParameter['prefix'] = prefix;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Logs returns the logs for a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clusterServiceLogs: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling clusterServiceLogs.'
        );
      }
      const localVarPath = `/v1/cluster/{id}/logs`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ClusterServiceApi - functional programming interface
 * @export
 */
export const ClusterServiceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Artifacts returns the artifacts for a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clusterServiceArtifacts(
      id: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ClusterArtifacts>> {
      const localVarAxiosArgs = await ClusterServiceApiAxiosParamCreator(
        configuration
      ).clusterServiceArtifacts(id, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Create launches a new cluster.
     * @param {V1CreateClusterRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clusterServiceCreate(
      body: V1CreateClusterRequest,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ResourceByID>> {
      const localVarAxiosArgs = await ClusterServiceApiAxiosParamCreator(
        configuration
      ).clusterServiceCreate(body, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Delete deletes an existing cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clusterServiceDelete(
      id: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await ClusterServiceApiAxiosParamCreator(
        configuration
      ).clusterServiceDelete(id, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Info provides information about a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clusterServiceInfo(
      id: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Cluster>> {
      const localVarAxiosArgs = await ClusterServiceApiAxiosParamCreator(
        configuration
      ).clusterServiceInfo(id, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Lifespan updates the lifespan for a specific cluster.
     * @param {string} id ID is the unique ID for the cluster.
     * @param {InlineObject} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clusterServiceLifespan(
      id: string,
      body: InlineObject,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await ClusterServiceApiAxiosParamCreator(
        configuration
      ).clusterServiceLifespan(id, body, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary List provides information about the available clusters.
     * @param {boolean} [all] all indicates that all clusters should be returned, not just the ones owned by the user.
     * @param {boolean} [expired] expired indicates that expired clusters should be returned, not just the ones that are launching/ready.
     * @param {string} [prefix] list clusters whose ID matches this prefix.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clusterServiceList(
      all?: boolean,
      expired?: boolean,
      prefix?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ClusterListResponse>> {
      const localVarAxiosArgs = await ClusterServiceApiAxiosParamCreator(
        configuration
      ).clusterServiceList(all, expired, prefix, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Logs returns the logs for a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clusterServiceLogs(
      id: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1LogsResponse>> {
      const localVarAxiosArgs = await ClusterServiceApiAxiosParamCreator(
        configuration
      ).clusterServiceLogs(id, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * ClusterServiceApi - factory interface
 * @export
 */
export const ClusterServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Artifacts returns the artifacts for a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clusterServiceArtifacts(id: string, options?: any): AxiosPromise<V1ClusterArtifacts> {
      return ClusterServiceApiFp(configuration)
        .clusterServiceArtifacts(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create launches a new cluster.
     * @param {V1CreateClusterRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clusterServiceCreate(
      body: V1CreateClusterRequest,
      options?: any
    ): AxiosPromise<V1ResourceByID> {
      return ClusterServiceApiFp(configuration)
        .clusterServiceCreate(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete deletes an existing cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clusterServiceDelete(id: string, options?: any): AxiosPromise<object> {
      return ClusterServiceApiFp(configuration)
        .clusterServiceDelete(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Info provides information about a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clusterServiceInfo(id: string, options?: any): AxiosPromise<V1Cluster> {
      return ClusterServiceApiFp(configuration)
        .clusterServiceInfo(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Lifespan updates the lifespan for a specific cluster.
     * @param {string} id ID is the unique ID for the cluster.
     * @param {InlineObject} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clusterServiceLifespan(id: string, body: InlineObject, options?: any): AxiosPromise<string> {
      return ClusterServiceApiFp(configuration)
        .clusterServiceLifespan(id, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List provides information about the available clusters.
     * @param {boolean} [all] all indicates that all clusters should be returned, not just the ones owned by the user.
     * @param {boolean} [expired] expired indicates that expired clusters should be returned, not just the ones that are launching/ready.
     * @param {string} [prefix] list clusters whose ID matches this prefix.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clusterServiceList(
      all?: boolean,
      expired?: boolean,
      prefix?: string,
      options?: any
    ): AxiosPromise<V1ClusterListResponse> {
      return ClusterServiceApiFp(configuration)
        .clusterServiceList(all, expired, prefix, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Logs returns the logs for a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clusterServiceLogs(id: string, options?: any): AxiosPromise<V1LogsResponse> {
      return ClusterServiceApiFp(configuration)
        .clusterServiceLogs(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ClusterServiceApi - object-oriented interface
 * @export
 * @class ClusterServiceApi
 * @extends {BaseAPI}
 */
export class ClusterServiceApi extends BaseAPI {
  /**
   *
   * @summary Artifacts returns the artifacts for a specific cluster.
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public clusterServiceArtifacts(id: string, options?: any) {
    return ClusterServiceApiFp(this.configuration)
      .clusterServiceArtifacts(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create launches a new cluster.
   * @param {V1CreateClusterRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public clusterServiceCreate(body: V1CreateClusterRequest, options?: any) {
    return ClusterServiceApiFp(this.configuration)
      .clusterServiceCreate(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete deletes an existing cluster.
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public clusterServiceDelete(id: string, options?: any) {
    return ClusterServiceApiFp(this.configuration)
      .clusterServiceDelete(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Info provides information about a specific cluster.
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public clusterServiceInfo(id: string, options?: any) {
    return ClusterServiceApiFp(this.configuration)
      .clusterServiceInfo(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Lifespan updates the lifespan for a specific cluster.
   * @param {string} id ID is the unique ID for the cluster.
   * @param {InlineObject} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public clusterServiceLifespan(id: string, body: InlineObject, options?: any) {
    return ClusterServiceApiFp(this.configuration)
      .clusterServiceLifespan(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List provides information about the available clusters.
   * @param {boolean} [all] all indicates that all clusters should be returned, not just the ones owned by the user.
   * @param {boolean} [expired] expired indicates that expired clusters should be returned, not just the ones that are launching/ready.
   * @param {string} [prefix] list clusters whose ID matches this prefix.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public clusterServiceList(all?: boolean, expired?: boolean, prefix?: string, options?: any) {
    return ClusterServiceApiFp(this.configuration)
      .clusterServiceList(all, expired, prefix, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Logs returns the logs for a specific cluster.
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public clusterServiceLogs(id: string, options?: any) {
    return ClusterServiceApiFp(this.configuration)
      .clusterServiceLogs(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FlavorServiceApi - axios parameter creator
 * @export
 */
export const FlavorServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Info provides information about a specific flavor.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    flavorServiceInfo: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling flavorServiceInfo.'
        );
      }
      const localVarPath = `/v1/flavor/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List provides information about the available flavors.
     * @param {boolean} [all] all indicates that all flavors should be returned, by default availability alpha clusters are excluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    flavorServiceList: async (all?: boolean, options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/flavor`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (all !== undefined) {
        localVarQueryParameter['all'] = all;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FlavorServiceApi - functional programming interface
 * @export
 */
export const FlavorServiceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Info provides information about a specific flavor.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async flavorServiceInfo(
      id: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Flavor>> {
      const localVarAxiosArgs = await FlavorServiceApiAxiosParamCreator(
        configuration
      ).flavorServiceInfo(id, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary List provides information about the available flavors.
     * @param {boolean} [all] all indicates that all flavors should be returned, by default availability alpha clusters are excluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async flavorServiceList(
      all?: boolean,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1FlavorListResponse>> {
      const localVarAxiosArgs = await FlavorServiceApiAxiosParamCreator(
        configuration
      ).flavorServiceList(all, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * FlavorServiceApi - factory interface
 * @export
 */
export const FlavorServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Info provides information about a specific flavor.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    flavorServiceInfo(id: string, options?: any): AxiosPromise<V1Flavor> {
      return FlavorServiceApiFp(configuration)
        .flavorServiceInfo(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List provides information about the available flavors.
     * @param {boolean} [all] all indicates that all flavors should be returned, by default availability alpha clusters are excluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    flavorServiceList(all?: boolean, options?: any): AxiosPromise<V1FlavorListResponse> {
      return FlavorServiceApiFp(configuration)
        .flavorServiceList(all, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * FlavorServiceApi - object-oriented interface
 * @export
 * @class FlavorServiceApi
 * @extends {BaseAPI}
 */
export class FlavorServiceApi extends BaseAPI {
  /**
   *
   * @summary Info provides information about a specific flavor.
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlavorServiceApi
   */
  public flavorServiceInfo(id: string, options?: any) {
    return FlavorServiceApiFp(this.configuration)
      .flavorServiceInfo(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List provides information about the available flavors.
   * @param {boolean} [all] all indicates that all flavors should be returned, by default availability alpha clusters are excluded.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlavorServiceApi
   */
  public flavorServiceList(all?: boolean, options?: any) {
    return FlavorServiceApiFp(this.configuration)
      .flavorServiceList(all, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * InfraStatusServiceApi - axios parameter creator
 * @export
 */
export const InfraStatusServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary GetStatus gets the maintenance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    infraStatusServiceGetStatus: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/status`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary ResetStatus resets the maintenance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    infraStatusServiceResetStatus: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/status`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary SetStatus sets the maintenance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    infraStatusServiceSetStatus: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/status`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InfraStatusServiceApi - functional programming interface
 * @export
 */
export const InfraStatusServiceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary GetStatus gets the maintenance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async infraStatusServiceGetStatus(
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1InfraStatus>> {
      const localVarAxiosArgs = await InfraStatusServiceApiAxiosParamCreator(
        configuration
      ).infraStatusServiceGetStatus(options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary ResetStatus resets the maintenance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async infraStatusServiceResetStatus(
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1InfraStatus>> {
      const localVarAxiosArgs = await InfraStatusServiceApiAxiosParamCreator(
        configuration
      ).infraStatusServiceResetStatus(options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary SetStatus sets the maintenance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async infraStatusServiceSetStatus(
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1InfraStatus>> {
      const localVarAxiosArgs = await InfraStatusServiceApiAxiosParamCreator(
        configuration
      ).infraStatusServiceSetStatus(options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * InfraStatusServiceApi - factory interface
 * @export
 */
export const InfraStatusServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary GetStatus gets the maintenance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    infraStatusServiceGetStatus(options?: any): AxiosPromise<V1InfraStatus> {
      return InfraStatusServiceApiFp(configuration)
        .infraStatusServiceGetStatus(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary ResetStatus resets the maintenance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    infraStatusServiceResetStatus(options?: any): AxiosPromise<V1InfraStatus> {
      return InfraStatusServiceApiFp(configuration)
        .infraStatusServiceResetStatus(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary SetStatus sets the maintenance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    infraStatusServiceSetStatus(options?: any): AxiosPromise<V1InfraStatus> {
      return InfraStatusServiceApiFp(configuration)
        .infraStatusServiceSetStatus(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * InfraStatusServiceApi - object-oriented interface
 * @export
 * @class InfraStatusServiceApi
 * @extends {BaseAPI}
 */
export class InfraStatusServiceApi extends BaseAPI {
  /**
   *
   * @summary GetStatus gets the maintenance
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfraStatusServiceApi
   */
  public infraStatusServiceGetStatus(options?: any) {
    return InfraStatusServiceApiFp(this.configuration)
      .infraStatusServiceGetStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary ResetStatus resets the maintenance
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfraStatusServiceApi
   */
  public infraStatusServiceResetStatus(options?: any) {
    return InfraStatusServiceApiFp(this.configuration)
      .infraStatusServiceResetStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary SetStatus sets the maintenance
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfraStatusServiceApi
   */
  public infraStatusServiceSetStatus(options?: any) {
    return InfraStatusServiceApiFp(this.configuration)
      .infraStatusServiceSetStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserServiceApi - axios parameter creator
 * @export
 */
export const UserServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {V1ServiceAccount} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userServiceCreateToken: async (
      body: V1ServiceAccount,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling userServiceCreateToken.'
        );
      }
      const localVarPath = `/v1/token-create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof body !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Token generates a service account token for the current user.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userServiceToken: async (body: object, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling userServiceToken.'
        );
      }
      const localVarPath = `/v1/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof body !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Whoami provides information about the currently authenticated principal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userServiceWhoami: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/whoami`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserServiceApi - functional programming interface
 * @export
 */
export const UserServiceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {V1ServiceAccount} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userServiceCreateToken(
      body: V1ServiceAccount,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1TokenResponse>> {
      const localVarAxiosArgs = await UserServiceApiAxiosParamCreator(
        configuration
      ).userServiceCreateToken(body, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Token generates a service account token for the current user.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userServiceToken(
      body: object,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1TokenResponse>> {
      const localVarAxiosArgs = await UserServiceApiAxiosParamCreator(
        configuration
      ).userServiceToken(body, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Whoami provides information about the currently authenticated principal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userServiceWhoami(
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1WhoamiResponse>> {
      const localVarAxiosArgs = await UserServiceApiAxiosParamCreator(
        configuration
      ).userServiceWhoami(options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * UserServiceApi - factory interface
 * @export
 */
export const UserServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {V1ServiceAccount} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userServiceCreateToken(body: V1ServiceAccount, options?: any): AxiosPromise<V1TokenResponse> {
      return UserServiceApiFp(configuration)
        .userServiceCreateToken(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Token generates a service account token for the current user.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userServiceToken(body: object, options?: any): AxiosPromise<V1TokenResponse> {
      return UserServiceApiFp(configuration)
        .userServiceToken(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Whoami provides information about the currently authenticated principal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userServiceWhoami(options?: any): AxiosPromise<V1WhoamiResponse> {
      return UserServiceApiFp(configuration)
        .userServiceWhoami(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserServiceApi - object-oriented interface
 * @export
 * @class UserServiceApi
 * @extends {BaseAPI}
 */
export class UserServiceApi extends BaseAPI {
  /**
   *
   * @summary CreateToken generates an arbitrary service account token
   * @param {V1ServiceAccount} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserServiceApi
   */
  public userServiceCreateToken(body: V1ServiceAccount, options?: any) {
    return UserServiceApiFp(this.configuration)
      .userServiceCreateToken(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Token generates a service account token for the current user.
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserServiceApi
   */
  public userServiceToken(body: object, options?: any) {
    return UserServiceApiFp(this.configuration)
      .userServiceToken(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Whoami provides information about the currently authenticated principal.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserServiceApi
   */
  public userServiceWhoami(options?: any) {
    return UserServiceApiFp(this.configuration)
      .userServiceWhoami(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * VersionServiceApi - axios parameter creator
 * @export
 */
export const VersionServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    versionServiceGetVersion: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/version`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VersionServiceApi - functional programming interface
 * @export
 */
export const VersionServiceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async versionServiceGetVersion(
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Version>> {
      const localVarAxiosArgs = await VersionServiceApiAxiosParamCreator(
        configuration
      ).versionServiceGetVersion(options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * VersionServiceApi - factory interface
 * @export
 */
export const VersionServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    versionServiceGetVersion(options?: any): AxiosPromise<V1Version> {
      return VersionServiceApiFp(configuration)
        .versionServiceGetVersion(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * VersionServiceApi - object-oriented interface
 * @export
 * @class VersionServiceApi
 * @extends {BaseAPI}
 */
export class VersionServiceApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VersionServiceApi
   */
  public versionServiceGetVersion(options?: any) {
    return VersionServiceApiFp(this.configuration)
      .versionServiceGetVersion(options)
      .then((request) => request(this.axios, this.basePath));
  }
}
