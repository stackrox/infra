/* tslint:disable */
/* eslint-disable */
/**
 * service.proto
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * availability represents the availability classification levels.   - alpha: alpha is completely experemental, and is not expected to work in any way.  - beta: beta is being tested, and is expected to work with minor issues.  - stable: stable is available for public consumption, and works without issue.  - default: default is stable, and available for customer demo consumption. Exactly 1 flavor should be configured as default.  - test: test are flavors for e2e and unit testing  - janitorDelete: janitorDelete is for deleting clusters with the Infra Janitor.  - deprecated: deprecated is a flavor that is no longer supported and will be removed in the future.
 * @export
 * @enum {string}
 */
export enum Flavoravailability {
  Alpha = 'alpha',
  Beta = 'beta',
  Stable = 'stable',
  Default = 'default',
  Test = 'test',
  JanitorDelete = 'janitorDelete',
  Deprecated = 'deprecated',
}

/**
 * method represents the various lifespan operations.   - REPLACE: REPLACE indicates that the given lifespan should replace the current lifespan.  - ADD: ADD indicates that the given lifespan should be added to the current lifespan.  - SUBTRACT: SUBTRACT indicates that the given lifespan should be subtracted from the current lifespan.
 * @export
 * @enum {string}
 */
export enum LifespanRequestMethod {
  Replace = 'REPLACE',
  Add = 'ADD',
  Subtract = 'SUBTRACT',
}

/**
 *
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
  /**
   *
   * @type {string}
   * @memberof ProtobufAny
   */
  type_url?: string;
  /**
   *
   * @type {string}
   * @memberof ProtobufAny
   */
  value?: string;
}
/**
 *
 * @export
 * @interface RuntimeStreamError
 */
export interface RuntimeStreamError {
  /**
   *
   * @type {number}
   * @memberof RuntimeStreamError
   */
  grpc_code?: number;
  /**
   *
   * @type {number}
   * @memberof RuntimeStreamError
   */
  http_code?: number;
  /**
   *
   * @type {string}
   * @memberof RuntimeStreamError
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof RuntimeStreamError
   */
  http_status?: string;
  /**
   *
   * @type {Array<ProtobufAny>}
   * @memberof RuntimeStreamError
   */
  details?: Array<ProtobufAny>;
}
/**
 *
 * @export
 * @interface V1Artifact
 */
export interface V1Artifact {
  /**
   *
   * @type {string}
   * @memberof V1Artifact
   */
  Name?: string;
  /**
   *
   * @type {string}
   * @memberof V1Artifact
   */
  Description?: string;
  /**
   *
   * @type {string}
   * @memberof V1Artifact
   */
  URL?: string;
  /**
   *
   * @type {number}
   * @memberof V1Artifact
   */
  Mode?: number;
}
/**
 *
 * @export
 * @interface V1CliUpgradeResponse
 */
export interface V1CliUpgradeResponse {
  /**
   *
   * @type {string}
   * @memberof V1CliUpgradeResponse
   */
  fileChunk?: string;
}
/**
 * Cluster represents a single cluster.
 * @export
 * @interface V1Cluster
 */
export interface V1Cluster {
  /**
   * ID is the unique ID for the cluster.
   * @type {string}
   * @memberof V1Cluster
   */
  ID?: string;
  /**
   *
   * @type {V1Status}
   * @memberof V1Cluster
   */
  Status?: V1Status;
  /**
   * Flavor is the original flavor ID that launched this cluster.
   * @type {string}
   * @memberof V1Cluster
   */
  Flavor?: string;
  /**
   * Owner is the email address for the cluster owner.
   * @type {string}
   * @memberof V1Cluster
   */
  Owner?: string;
  /**
   * CreatedOn is the timestamp on which the cluster started being created.
   * @type {string}
   * @memberof V1Cluster
   */
  CreatedOn?: string;
  /**
   * DestroyedOn is the timestamp on which the cluster finished being destroyed.
   * @type {string}
   * @memberof V1Cluster
   */
  DestroyedOn?: string;
  /**
   * Lifespan is the duration for which the cluster should be kept alive.
   * @type {string}
   * @memberof V1Cluster
   */
  Lifespan?: string;
  /**
   * Description is a human readable description for the cluster.
   * @type {string}
   * @memberof V1Cluster
   */
  Description?: string;
  /**
   * URL is an optional URL for this cluster.
   * @type {string}
   * @memberof V1Cluster
   */
  URL?: string;
  /**
   * Connect is a command to add kube connection information to kubeconfig.
   * @type {string}
   * @memberof V1Cluster
   */
  Connect?: string;
  /**
   * Parameters is a list of options to configure the cluster creation.
   * @type {Array<V1Parameter>}
   * @memberof V1Cluster
   */
  Parameters?: Array<V1Parameter>;
}
/**
 *
 * @export
 * @interface V1ClusterArtifacts
 */
export interface V1ClusterArtifacts {
  /**
   *
   * @type {Array<V1Artifact>}
   * @memberof V1ClusterArtifacts
   */
  Artifacts?: Array<V1Artifact>;
}
/**
 * ClusterListResponse represents details about all clusters.
 * @export
 * @interface V1ClusterListResponse
 */
export interface V1ClusterListResponse {
  /**
   * Clusters is a list of all clusters.
   * @type {Array<V1Cluster>}
   * @memberof V1ClusterListResponse
   */
  Clusters?: Array<V1Cluster>;
}
/**
 * CreateClusterRequest represents details for launching a new cluster.
 * @export
 * @interface V1CreateClusterRequest
 */
export interface V1CreateClusterRequest {
  /**
   * ID is the flavor ID to launch.
   * @type {string}
   * @memberof V1CreateClusterRequest
   */
  ID?: string;
  /**
   * Lifespan is the initial cluster lifespan.
   * @type {string}
   * @memberof V1CreateClusterRequest
   */
  Lifespan?: string;
  /**
   * Parameters is a map of launch parameter names to values.
   * @type {{ [key: string]: string; }}
   * @memberof V1CreateClusterRequest
   */
  Parameters?: { [key: string]: string };
  /**
   * Description is a human readable description for the cluster.
   * @type {string}
   * @memberof V1CreateClusterRequest
   */
  Description?: string;
  /**
   * NoSlack is used to skip sending Slack messages for cluster lifecycle events.
   * @type {boolean}
   * @memberof V1CreateClusterRequest
   */
  NoSlack?: boolean;
  /**
   * SlackDM is used to choose direct messages for cluster lifecycle events.
   * @type {boolean}
   * @memberof V1CreateClusterRequest
   */
  SlackDM?: boolean;
}
/**
 * Flavor represents a configured cluster flavor.
 * @export
 * @interface V1Flavor
 */
export interface V1Flavor {
  /**
   * ID is the unique, human type-able, ID for the flavor.
   * @type {string}
   * @memberof V1Flavor
   */
  ID?: string;
  /**
   * Name is a human readable name for the flavor.
   * @type {string}
   * @memberof V1Flavor
   */
  Name?: string;
  /**
   * Description is a human readable description for the flavor.
   * @type {string}
   * @memberof V1Flavor
   */
  Description?: string;
  /**
   *
   * @type {Flavoravailability}
   * @memberof V1Flavor
   */
  Availability?: Flavoravailability;
  /**
   * Parameters is a map of parameters required for launching this flavor.
   * @type {{ [key: string]: V1Parameter; }}
   * @memberof V1Flavor
   */
  Parameters?: { [key: string]: V1Parameter };
  /**
   * Artifacts is a map of artifacts produced by this flavor.
   * @type {{ [key: string]: V1FlavorArtifact; }}
   * @memberof V1Flavor
   */
  Artifacts?: { [key: string]: V1FlavorArtifact };
  /**
   * Aliases are alternative IDs of the flavor.
   * @type {Array<string>}
   * @memberof V1Flavor
   */
  Aliases?: Array<string>;
}
/**
 * FlavorArtifact represents a single artifact that is produced by a flavor.
 * @export
 * @interface V1FlavorArtifact
 */
export interface V1FlavorArtifact {
  /**
   * Name is the unique name of the artifact.
   * @type {string}
   * @memberof V1FlavorArtifact
   */
  Name?: string;
  /**
   * Description is a human readable description for the artifact.
   * @type {string}
   * @memberof V1FlavorArtifact
   */
  Description?: string;
  /**
   * Tags is a set of artifact tags.
   * @type {{ [key: string]: object; }}
   * @memberof V1FlavorArtifact
   */
  Tags?: { [key: string]: object };
}
/**
 * FlavorListResponse represents details about the available cluster flavors.
 * @export
 * @interface V1FlavorListResponse
 */
export interface V1FlavorListResponse {
  /**
   * Default is the flavor ID of the default cluster flavor.
   * @type {string}
   * @memberof V1FlavorListResponse
   */
  Default?: string;
  /**
   * Flavors is a list of all available cluster flavors.
   * @type {Array<V1Flavor>}
   * @memberof V1FlavorListResponse
   */
  Flavors?: Array<V1Flavor>;
}
/**
 *
 * @export
 * @interface V1InfraStatus
 */
export interface V1InfraStatus {
  /**
   * MaintenanceActive is an indicator whether a maintenance is ongoing.
   * @type {boolean}
   * @memberof V1InfraStatus
   */
  MaintenanceActive?: boolean;
  /**
   * Maintainer is the email of the person currently doing maintenance.
   * @type {string}
   * @memberof V1InfraStatus
   */
  Maintainer?: string;
}
/**
 *
 * @export
 * @interface V1LifespanRequest
 */
export interface V1LifespanRequest {
  /**
   * ID is the unique ID for the cluster.
   * @type {string}
   * @memberof V1LifespanRequest
   */
  id?: string;
  /**
   * Lifespan is the new lifespan.
   * @type {string}
   * @memberof V1LifespanRequest
   */
  Lifespan?: string;
  /**
   *
   * @type {LifespanRequestMethod}
   * @memberof V1LifespanRequest
   */
  method?: LifespanRequestMethod;
}
/**
 * Log represents the logs from a specific pod.
 * @export
 * @interface V1Log
 */
export interface V1Log {
  /**
   * Name is the name given to this pod in the workflow.
   * @type {string}
   * @memberof V1Log
   */
  Name?: string;
  /**
   * Started is the time at which this pod was started. Used for ordering between pods.
   * @type {string}
   * @memberof V1Log
   */
  Started?: string;
  /**
   * Body is the raw pod logs.
   * @type {string}
   * @memberof V1Log
   */
  Body?: string;
  /**
   * Message surfaces step state from Argo.
   * @type {string}
   * @memberof V1Log
   */
  Message?: string;
}
/**
 * LogsResponse represents a collection of logs.
 * @export
 * @interface V1LogsResponse
 */
export interface V1LogsResponse {
  /**
   * Logs are all of the logs from a cluster.
   * @type {Array<V1Log>}
   * @memberof V1LogsResponse
   */
  Logs?: Array<V1Log>;
}
/**
 * Parameter represents a single parameter that is needed to launch a flavor.
 * @export
 * @interface V1Parameter
 */
export interface V1Parameter {
  /**
   * Name is the unique name of the parameter.
   * @type {string}
   * @memberof V1Parameter
   */
  Name?: string;
  /**
   * Description is a human readable description for the parameter.
   * @type {string}
   * @memberof V1Parameter
   */
  Description?: string;
  /**
   * Value that this parameter could have. If the parameter is not optional, then value serves as an example. If the parameter is optional, then value serves as a default. If the parameter is internal, then value serves as a hardcoded constant.
   * @type {string}
   * @memberof V1Parameter
   */
  Value?: string;
  /**
   * Optional indicates that this parameter can be optionally provided by a user. If the user does not provide a value, then Value serves as a default.
   * @type {boolean}
   * @memberof V1Parameter
   */
  Optional?: boolean;
  /**
   * Internal indicates that this parameter should not be provided by a user, but rather treats Value as a hardcoded constant.
   * @type {boolean}
   * @memberof V1Parameter
   */
  Internal?: boolean;
  /**
   * The relative order of importance of this parameter for when presenting in a UI for example.
   * @type {number}
   * @memberof V1Parameter
   */
  Order?: number;
  /**
   *
   * @type {string}
   * @memberof V1Parameter
   */
  Help?: string;
  /**
   * Indicates that the value for this parameter can be provided from the contents of a file.
   * @type {boolean}
   * @memberof V1Parameter
   */
  FromFile?: boolean;
}
/**
 * ResourceByID represents a generic reference to a named/unique resource.
 * @export
 * @interface V1ResourceByID
 */
export interface V1ResourceByID {
  /**
   *
   * @type {string}
   * @memberof V1ResourceByID
   */
  id?: string;
}
/**
 * ServiceAccount represents an authenticated service account (robot) principal.
 * @export
 * @interface V1ServiceAccount
 */
export interface V1ServiceAccount {
  /**
   * Name is a human readable name for the service account.
   * @type {string}
   * @memberof V1ServiceAccount
   */
  Name?: string;
  /**
   * Description is a human readable description for the service account.
   * @type {string}
   * @memberof V1ServiceAccount
   */
  Description?: string;
  /**
   * Email is the Red Hat email address for the service account.
   * @type {string}
   * @memberof V1ServiceAccount
   */
  Email?: string;
  /**
   * IssuedAt is the time of issuing the service account token.
   * @type {string}
   * @memberof V1ServiceAccount
   */
  IssuedAt?: string;
  /**
   * NotBefore is the beginning of service account token valid time period.
   * @type {string}
   * @memberof V1ServiceAccount
   */
  NotBefore?: string;
  /**
   * ExpiresAt is the end of service account token valid time period.
   * @type {string}
   * @memberof V1ServiceAccount
   */
  ExpiresAt?: string;
}
/**
 * Status represents the various cluster states.   - FAILED: FAILED is the state when the cluster has failed in one way or another.  - CREATING: CREATING is the state when the cluster is being created.  - READY: READY is the state when the cluster is available and ready for use.  - DESTROYING: DESTROYING is the state when the cluster is being destroyed.  - FINISHED: FINISHED is the state when the cluster has been successfully destroyed.
 * @export
 * @enum {string}
 */
export enum V1Status {
  Failed = 'FAILED',
  Creating = 'CREATING',
  Ready = 'READY',
  Destroying = 'DESTROYING',
  Finished = 'FINISHED',
}

/**
 *
 * @export
 * @interface V1TokenResponse
 */
export interface V1TokenResponse {
  /**
   *
   * @type {V1ServiceAccount}
   * @memberof V1TokenResponse
   */
  Account?: V1ServiceAccount;
  /**
   * Token is the token generated for the service account.
   * @type {string}
   * @memberof V1TokenResponse
   */
  Token?: string;
}
/**
 * User represents an authenticated (human) principal.
 * @export
 * @interface V1User
 */
export interface V1User {
  /**
   * Expiry is the expiration date of this user session. Used only as a hint to the user and not for enforcement.
   * @type {string}
   * @memberof V1User
   */
  Expiry?: string;
  /**
   * Name is the full name of the user.
   * @type {string}
   * @memberof V1User
   */
  Name?: string;
  /**
   * Email is the email address of the user.
   * @type {string}
   * @memberof V1User
   */
  Email?: string;
  /**
   * Picture is a URL linking to this user\'s profile picture, if available.
   * @type {string}
   * @memberof V1User
   */
  Picture?: string;
}
/**
 *
 * @export
 * @interface V1Version
 */
export interface V1Version {
  /**
   *
   * @type {string}
   * @memberof V1Version
   */
  BuildDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1Version
   */
  GitCommit?: string;
  /**
   *
   * @type {string}
   * @memberof V1Version
   */
  GoVersion?: string;
  /**
   *
   * @type {string}
   * @memberof V1Version
   */
  Platform?: string;
  /**
   *
   * @type {string}
   * @memberof V1Version
   */
  Version?: string;
  /**
   *
   * @type {string}
   * @memberof V1Version
   */
  Workflow?: string;
}
/**
 * WhoamiResponse represents details about the current authenticated principal.
 * @export
 * @interface V1WhoamiResponse
 */
export interface V1WhoamiResponse {
  /**
   *
   * @type {V1User}
   * @memberof V1WhoamiResponse
   */
  User?: V1User;
  /**
   *
   * @type {V1ServiceAccount}
   * @memberof V1WhoamiResponse
   */
  ServiceAccount?: V1ServiceAccount;
}

/**
 * CliServiceApi - axios parameter creator
 * @export
 */
export const CliServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} os
     * @param {string} arch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgrade: async (os: string, arch: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'os' is not null or undefined
      if (os === null || os === undefined) {
        throw new RequiredError(
          'os',
          'Required parameter os was null or undefined when calling upgrade.'
        );
      }
      // verify required parameter 'arch' is not null or undefined
      if (arch === null || arch === undefined) {
        throw new RequiredError(
          'arch',
          'Required parameter arch was null or undefined when calling upgrade.'
        );
      }
      const localVarPath = `/v1/cli/{os}/{arch}/upgrade`
        .replace(`{${'os'}}`, encodeURIComponent(String(os)))
        .replace(`{${'arch'}}`, encodeURIComponent(String(arch)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CliServiceApi - functional programming interface
 * @export
 */
export const CliServiceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} os
     * @param {string} arch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async upgrade(
      os: string,
      arch: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await CliServiceApiAxiosParamCreator(configuration).upgrade(
        os,
        arch,
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * CliServiceApi - factory interface
 * @export
 */
export const CliServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @param {string} os
     * @param {string} arch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgrade(os: string, arch: string, options?: any): AxiosPromise<object> {
      return CliServiceApiFp(configuration)
        .upgrade(os, arch, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CliServiceApi - object-oriented interface
 * @export
 * @class CliServiceApi
 * @extends {BaseAPI}
 */
export class CliServiceApi extends BaseAPI {
  /**
   *
   * @param {string} os
   * @param {string} arch
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CliServiceApi
   */
  public upgrade(os: string, arch: string, options?: any) {
    return CliServiceApiFp(this.configuration)
      .upgrade(os, arch, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ClusterServiceApi - axios parameter creator
 * @export
 */
export const ClusterServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete deletes an existing cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling _delete.'
        );
      }
      const localVarPath = `/v1/cluster/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Artifacts returns the artifacts for a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    artifacts: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling artifacts.'
        );
      }
      const localVarPath = `/v1/cluster/{id}/artifacts`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create launches a new cluster.
     * @param {V1CreateClusterRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (body: V1CreateClusterRequest, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling create.'
        );
      }
      const localVarPath = `/v1/cluster`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof body !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    info: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling info.'
        );
      }
      const localVarPath = `/v1/cluster/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Token generates a service account token for the current user.
     * @param {string} id ID is the unique ID for the cluster.
     * @param {V1LifespanRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lifespan: async (
      id: string,
      body: V1LifespanRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling lifespan.'
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling lifespan.'
        );
      }
      const localVarPath = `/v1/cluster/{id}/lifespan`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof body !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {boolean} [all] all indicates that all clusters should be returned, not just the ones owned by the user.
     * @param {boolean} [expired] expired indicates that expired clusters should be returned, not just the ones that are launching/ready.
     * @param {string} [prefix] list clusters whose ID matches this prefix.
     * @param {Array<'FAILED' | 'CREATING' | 'READY' | 'DESTROYING' | 'FINISHED'>} [allowedStatuses] filter clusters whose Status is in the list.   - FAILED: FAILED is the state when the cluster has failed in one way or another.  - CREATING: CREATING is the state when the cluster is being created.  - READY: READY is the state when the cluster is available and ready for use.  - DESTROYING: DESTROYING is the state when the cluster is being destroyed.  - FINISHED: FINISHED is the state when the cluster has been successfully destroyed.
     * @param {Array<string>} [allowedFlavors] filter clusters whose flavor ID is in the list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      all?: boolean,
      expired?: boolean,
      prefix?: string,
      allowedStatuses?: Array<'FAILED' | 'CREATING' | 'READY' | 'DESTROYING' | 'FINISHED'>,
      allowedFlavors?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/cluster`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (all !== undefined) {
        localVarQueryParameter['all'] = all;
      }

      if (expired !== undefined) {
        localVarQueryParameter['expired'] = expired;
      }

      if (prefix !== undefined) {
        localVarQueryParameter['prefix'] = prefix;
      }

      if (allowedStatuses) {
        localVarQueryParameter['allowedStatuses'] = allowedStatuses;
      }

      if (allowedFlavors) {
        localVarQueryParameter['allowedFlavors'] = allowedFlavors;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Logs returns the logs for a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logs: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling logs.'
        );
      }
      const localVarPath = `/v1/cluster/{id}/logs`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ClusterServiceApi - functional programming interface
 * @export
 */
export const ClusterServiceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete deletes an existing cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      id: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await ClusterServiceApiAxiosParamCreator(configuration)._delete(
        id,
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Artifacts returns the artifacts for a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async artifacts(
      id: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ClusterArtifacts>> {
      const localVarAxiosArgs = await ClusterServiceApiAxiosParamCreator(configuration).artifacts(
        id,
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Create launches a new cluster.
     * @param {V1CreateClusterRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      body: V1CreateClusterRequest,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ResourceByID>> {
      const localVarAxiosArgs = await ClusterServiceApiAxiosParamCreator(configuration).create(
        body,
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async info(
      id: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Cluster>> {
      const localVarAxiosArgs = await ClusterServiceApiAxiosParamCreator(configuration).info(
        id,
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Token generates a service account token for the current user.
     * @param {string} id ID is the unique ID for the cluster.
     * @param {V1LifespanRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lifespan(
      id: string,
      body: V1LifespanRequest,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await ClusterServiceApiAxiosParamCreator(configuration).lifespan(
        id,
        body,
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {boolean} [all] all indicates that all clusters should be returned, not just the ones owned by the user.
     * @param {boolean} [expired] expired indicates that expired clusters should be returned, not just the ones that are launching/ready.
     * @param {string} [prefix] list clusters whose ID matches this prefix.
     * @param {Array<'FAILED' | 'CREATING' | 'READY' | 'DESTROYING' | 'FINISHED'>} [allowedStatuses] filter clusters whose Status is in the list.   - FAILED: FAILED is the state when the cluster has failed in one way or another.  - CREATING: CREATING is the state when the cluster is being created.  - READY: READY is the state when the cluster is available and ready for use.  - DESTROYING: DESTROYING is the state when the cluster is being destroyed.  - FINISHED: FINISHED is the state when the cluster has been successfully destroyed.
     * @param {Array<string>} [allowedFlavors] filter clusters whose flavor ID is in the list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      all?: boolean,
      expired?: boolean,
      prefix?: string,
      allowedStatuses?: Array<'FAILED' | 'CREATING' | 'READY' | 'DESTROYING' | 'FINISHED'>,
      allowedFlavors?: Array<string>,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ClusterListResponse>> {
      const localVarAxiosArgs = await ClusterServiceApiAxiosParamCreator(configuration).list(
        all,
        expired,
        prefix,
        allowedStatuses,
        allowedFlavors,
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Logs returns the logs for a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logs(
      id: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1LogsResponse>> {
      const localVarAxiosArgs = await ClusterServiceApiAxiosParamCreator(configuration).logs(
        id,
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * ClusterServiceApi - factory interface
 * @export
 */
export const ClusterServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Delete deletes an existing cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(id: string, options?: any): AxiosPromise<object> {
      return ClusterServiceApiFp(configuration)
        ._delete(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Artifacts returns the artifacts for a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    artifacts(id: string, options?: any): AxiosPromise<V1ClusterArtifacts> {
      return ClusterServiceApiFp(configuration)
        .artifacts(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create launches a new cluster.
     * @param {V1CreateClusterRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(body: V1CreateClusterRequest, options?: any): AxiosPromise<V1ResourceByID> {
      return ClusterServiceApiFp(configuration)
        .create(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    info(id: string, options?: any): AxiosPromise<V1Cluster> {
      return ClusterServiceApiFp(configuration)
        .info(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Token generates a service account token for the current user.
     * @param {string} id ID is the unique ID for the cluster.
     * @param {V1LifespanRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lifespan(id: string, body: V1LifespanRequest, options?: any): AxiosPromise<string> {
      return ClusterServiceApiFp(configuration)
        .lifespan(id, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {boolean} [all] all indicates that all clusters should be returned, not just the ones owned by the user.
     * @param {boolean} [expired] expired indicates that expired clusters should be returned, not just the ones that are launching/ready.
     * @param {string} [prefix] list clusters whose ID matches this prefix.
     * @param {Array<'FAILED' | 'CREATING' | 'READY' | 'DESTROYING' | 'FINISHED'>} [allowedStatuses] filter clusters whose Status is in the list.   - FAILED: FAILED is the state when the cluster has failed in one way or another.  - CREATING: CREATING is the state when the cluster is being created.  - READY: READY is the state when the cluster is available and ready for use.  - DESTROYING: DESTROYING is the state when the cluster is being destroyed.  - FINISHED: FINISHED is the state when the cluster has been successfully destroyed.
     * @param {Array<string>} [allowedFlavors] filter clusters whose flavor ID is in the list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      all?: boolean,
      expired?: boolean,
      prefix?: string,
      allowedStatuses?: Array<'FAILED' | 'CREATING' | 'READY' | 'DESTROYING' | 'FINISHED'>,
      allowedFlavors?: Array<string>,
      options?: any
    ): AxiosPromise<V1ClusterListResponse> {
      return ClusterServiceApiFp(configuration)
        .list(all, expired, prefix, allowedStatuses, allowedFlavors, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Logs returns the logs for a specific cluster.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logs(id: string, options?: any): AxiosPromise<V1LogsResponse> {
      return ClusterServiceApiFp(configuration)
        .logs(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ClusterServiceApi - object-oriented interface
 * @export
 * @class ClusterServiceApi
 * @extends {BaseAPI}
 */
export class ClusterServiceApi extends BaseAPI {
  /**
   *
   * @summary Delete deletes an existing cluster.
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public _delete(id: string, options?: any) {
    return ClusterServiceApiFp(this.configuration)
      ._delete(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Artifacts returns the artifacts for a specific cluster.
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public artifacts(id: string, options?: any) {
    return ClusterServiceApiFp(this.configuration)
      .artifacts(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create launches a new cluster.
   * @param {V1CreateClusterRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public create(body: V1CreateClusterRequest, options?: any) {
    return ClusterServiceApiFp(this.configuration)
      .create(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public info(id: string, options?: any) {
    return ClusterServiceApiFp(this.configuration)
      .info(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Token generates a service account token for the current user.
   * @param {string} id ID is the unique ID for the cluster.
   * @param {V1LifespanRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public lifespan(id: string, body: V1LifespanRequest, options?: any) {
    return ClusterServiceApiFp(this.configuration)
      .lifespan(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary CreateToken generates an arbitrary service account token
   * @param {boolean} [all] all indicates that all clusters should be returned, not just the ones owned by the user.
   * @param {boolean} [expired] expired indicates that expired clusters should be returned, not just the ones that are launching/ready.
   * @param {string} [prefix] list clusters whose ID matches this prefix.
   * @param {Array<'FAILED' | 'CREATING' | 'READY' | 'DESTROYING' | 'FINISHED'>} [allowedStatuses] filter clusters whose Status is in the list.   - FAILED: FAILED is the state when the cluster has failed in one way or another.  - CREATING: CREATING is the state when the cluster is being created.  - READY: READY is the state when the cluster is available and ready for use.  - DESTROYING: DESTROYING is the state when the cluster is being destroyed.  - FINISHED: FINISHED is the state when the cluster has been successfully destroyed.
   * @param {Array<string>} [allowedFlavors] filter clusters whose flavor ID is in the list.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public list(
    all?: boolean,
    expired?: boolean,
    prefix?: string,
    allowedStatuses?: Array<'FAILED' | 'CREATING' | 'READY' | 'DESTROYING' | 'FINISHED'>,
    allowedFlavors?: Array<string>,
    options?: any
  ) {
    return ClusterServiceApiFp(this.configuration)
      .list(all, expired, prefix, allowedStatuses, allowedFlavors, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Logs returns the logs for a specific cluster.
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClusterServiceApi
   */
  public logs(id: string, options?: any) {
    return ClusterServiceApiFp(this.configuration)
      .logs(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FlavorServiceApi - axios parameter creator
 * @export
 */
export const FlavorServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    info: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling info.'
        );
      }
      const localVarPath = `/v1/flavor/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {boolean} [all] all indicates that all flavors should be returned, by default availability alpha clusters are excluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (all?: boolean, options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/flavor`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (all !== undefined) {
        localVarQueryParameter['all'] = all;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FlavorServiceApi - functional programming interface
 * @export
 */
export const FlavorServiceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async info(
      id: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Flavor>> {
      const localVarAxiosArgs = await FlavorServiceApiAxiosParamCreator(configuration).info(
        id,
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @param {boolean} [all] all indicates that all flavors should be returned, by default availability alpha clusters are excluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      all?: boolean,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1FlavorListResponse>> {
      const localVarAxiosArgs = await FlavorServiceApiAxiosParamCreator(configuration).list(
        all,
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * FlavorServiceApi - factory interface
 * @export
 */
export const FlavorServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    info(id: string, options?: any): AxiosPromise<V1Flavor> {
      return FlavorServiceApiFp(configuration)
        .info(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {boolean} [all] all indicates that all flavors should be returned, by default availability alpha clusters are excluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(all?: boolean, options?: any): AxiosPromise<V1FlavorListResponse> {
      return FlavorServiceApiFp(configuration)
        .list(all, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * FlavorServiceApi - object-oriented interface
 * @export
 * @class FlavorServiceApi
 * @extends {BaseAPI}
 */
export class FlavorServiceApi extends BaseAPI {
  /**
   *
   * @summary CreateToken generates an arbitrary service account token
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlavorServiceApi
   */
  public info(id: string, options?: any) {
    return FlavorServiceApiFp(this.configuration)
      .info(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {boolean} [all] all indicates that all flavors should be returned, by default availability alpha clusters are excluded.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlavorServiceApi
   */
  public list(all?: boolean, options?: any) {
    return FlavorServiceApiFp(this.configuration)
      .list(all, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * InfraStatusServiceApi - axios parameter creator
 * @export
 */
export const InfraStatusServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/status`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetStatus: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/status`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Token generates a service account token for the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setStatus: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/status`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InfraStatusServiceApi - functional programming interface
 * @export
 */
export const InfraStatusServiceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatus(
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1InfraStatus>> {
      const localVarAxiosArgs = await InfraStatusServiceApiAxiosParamCreator(
        configuration
      ).getStatus(options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resetStatus(
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1InfraStatus>> {
      const localVarAxiosArgs = await InfraStatusServiceApiAxiosParamCreator(
        configuration
      ).resetStatus(options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Token generates a service account token for the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setStatus(
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1InfraStatus>> {
      const localVarAxiosArgs = await InfraStatusServiceApiAxiosParamCreator(
        configuration
      ).setStatus(options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * InfraStatusServiceApi - factory interface
 * @export
 */
export const InfraStatusServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus(options?: any): AxiosPromise<V1InfraStatus> {
      return InfraStatusServiceApiFp(configuration)
        .getStatus(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetStatus(options?: any): AxiosPromise<V1InfraStatus> {
      return InfraStatusServiceApiFp(configuration)
        .resetStatus(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Token generates a service account token for the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setStatus(options?: any): AxiosPromise<V1InfraStatus> {
      return InfraStatusServiceApiFp(configuration)
        .setStatus(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * InfraStatusServiceApi - object-oriented interface
 * @export
 * @class InfraStatusServiceApi
 * @extends {BaseAPI}
 */
export class InfraStatusServiceApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfraStatusServiceApi
   */
  public getStatus(options?: any) {
    return InfraStatusServiceApiFp(this.configuration)
      .getStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary CreateToken generates an arbitrary service account token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfraStatusServiceApi
   */
  public resetStatus(options?: any) {
    return InfraStatusServiceApiFp(this.configuration)
      .resetStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Token generates a service account token for the current user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfraStatusServiceApi
   */
  public setStatus(options?: any) {
    return InfraStatusServiceApiFp(this.configuration)
      .setStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserServiceApi - axios parameter creator
 * @export
 */
export const UserServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {V1ServiceAccount} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken: async (body: V1ServiceAccount, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createToken.'
        );
      }
      const localVarPath = `/v1/token-create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof body !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Token generates a service account token for the current user.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    token: async (body: object, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling token.'
        );
      }
      const localVarPath = `/v1/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof body !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/whoami`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserServiceApi - functional programming interface
 * @export
 */
export const UserServiceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {V1ServiceAccount} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createToken(
      body: V1ServiceAccount,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1TokenResponse>> {
      const localVarAxiosArgs = await UserServiceApiAxiosParamCreator(configuration).createToken(
        body,
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Token generates a service account token for the current user.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async token(
      body: object,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1TokenResponse>> {
      const localVarAxiosArgs = await UserServiceApiAxiosParamCreator(configuration).token(
        body,
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async whoami(
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1WhoamiResponse>> {
      const localVarAxiosArgs = await UserServiceApiAxiosParamCreator(configuration).whoami(
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * UserServiceApi - factory interface
 * @export
 */
export const UserServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary CreateToken generates an arbitrary service account token
     * @param {V1ServiceAccount} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken(body: V1ServiceAccount, options?: any): AxiosPromise<V1TokenResponse> {
      return UserServiceApiFp(configuration)
        .createToken(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Token generates a service account token for the current user.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    token(body: object, options?: any): AxiosPromise<V1TokenResponse> {
      return UserServiceApiFp(configuration)
        .token(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami(options?: any): AxiosPromise<V1WhoamiResponse> {
      return UserServiceApiFp(configuration)
        .whoami(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserServiceApi - object-oriented interface
 * @export
 * @class UserServiceApi
 * @extends {BaseAPI}
 */
export class UserServiceApi extends BaseAPI {
  /**
   *
   * @summary CreateToken generates an arbitrary service account token
   * @param {V1ServiceAccount} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserServiceApi
   */
  public createToken(body: V1ServiceAccount, options?: any) {
    return UserServiceApiFp(this.configuration)
      .createToken(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Token generates a service account token for the current user.
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserServiceApi
   */
  public token(body: object, options?: any) {
    return UserServiceApiFp(this.configuration)
      .token(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserServiceApi
   */
  public whoami(options?: any) {
    return UserServiceApiFp(this.configuration)
      .whoami(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * VersionServiceApi - axios parameter creator
 * @export
 */
export const VersionServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/version`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VersionServiceApi - functional programming interface
 * @export
 */
export const VersionServiceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVersion(
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Version>> {
      const localVarAxiosArgs = await VersionServiceApiAxiosParamCreator(configuration).getVersion(
        options
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * VersionServiceApi - factory interface
 * @export
 */
export const VersionServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion(options?: any): AxiosPromise<V1Version> {
      return VersionServiceApiFp(configuration)
        .getVersion(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * VersionServiceApi - object-oriented interface
 * @export
 * @class VersionServiceApi
 * @extends {BaseAPI}
 */
export class VersionServiceApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VersionServiceApi
   */
  public getVersion(options?: any) {
    return VersionServiceApiFp(this.configuration)
      .getVersion(options)
      .then((request) => request(this.axios, this.basePath));
  }
}
