// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.0
// source: service.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	VersionService_GetVersion_FullMethodName = "/v1.VersionService/GetVersion"
)

// VersionServiceClient is the client API for VersionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VersionServiceClient interface {
	GetVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Version, error)
}

type versionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVersionServiceClient(cc grpc.ClientConnInterface) VersionServiceClient {
	return &versionServiceClient{cc}
}

func (c *versionServiceClient) GetVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Version, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Version)
	err := c.cc.Invoke(ctx, VersionService_GetVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VersionServiceServer is the server API for VersionService service.
// All implementations must embed UnimplementedVersionServiceServer
// for forward compatibility.
type VersionServiceServer interface {
	GetVersion(context.Context, *emptypb.Empty) (*Version, error)
	mustEmbedUnimplementedVersionServiceServer()
}

// UnimplementedVersionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVersionServiceServer struct{}

func (UnimplementedVersionServiceServer) GetVersion(context.Context, *emptypb.Empty) (*Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersion not implemented")
}
func (UnimplementedVersionServiceServer) mustEmbedUnimplementedVersionServiceServer() {}
func (UnimplementedVersionServiceServer) testEmbeddedByValue()                        {}

// UnsafeVersionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VersionServiceServer will
// result in compilation errors.
type UnsafeVersionServiceServer interface {
	mustEmbedUnimplementedVersionServiceServer()
}

func RegisterVersionServiceServer(s grpc.ServiceRegistrar, srv VersionServiceServer) {
	// If the following call pancis, it indicates UnimplementedVersionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VersionService_ServiceDesc, srv)
}

func _VersionService_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VersionServiceServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VersionService_GetVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VersionServiceServer).GetVersion(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// VersionService_ServiceDesc is the grpc.ServiceDesc for VersionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VersionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.VersionService",
	HandlerType: (*VersionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVersion",
			Handler:    _VersionService_GetVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	UserService_Whoami_FullMethodName      = "/v1.UserService/Whoami"
	UserService_CreateToken_FullMethodName = "/v1.UserService/CreateToken"
	UserService_Token_FullMethodName       = "/v1.UserService/Token"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	// Whoami provides information about the currently authenticated principal.
	Whoami(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WhoamiResponse, error)
	// CreateToken generates an arbitrary service account token
	CreateToken(ctx context.Context, in *ServiceAccount, opts ...grpc.CallOption) (*TokenResponse, error)
	// Token generates a service account token for the current user.
	Token(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TokenResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) Whoami(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WhoamiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WhoamiResponse)
	err := c.cc.Invoke(ctx, UserService_Whoami_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CreateToken(ctx context.Context, in *ServiceAccount, opts ...grpc.CallOption) (*TokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokenResponse)
	err := c.cc.Invoke(ctx, UserService_CreateToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Token(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokenResponse)
	err := c.cc.Invoke(ctx, UserService_Token_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
type UserServiceServer interface {
	// Whoami provides information about the currently authenticated principal.
	Whoami(context.Context, *emptypb.Empty) (*WhoamiResponse, error)
	// CreateToken generates an arbitrary service account token
	CreateToken(context.Context, *ServiceAccount) (*TokenResponse, error)
	// Token generates a service account token for the current user.
	Token(context.Context, *emptypb.Empty) (*TokenResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) Whoami(context.Context, *emptypb.Empty) (*WhoamiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Whoami not implemented")
}
func (UnimplementedUserServiceServer) CreateToken(context.Context, *ServiceAccount) (*TokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateToken not implemented")
}
func (UnimplementedUserServiceServer) Token(context.Context, *emptypb.Empty) (*TokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Token not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_Whoami_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Whoami(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_Whoami_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Whoami(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CreateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceAccount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateToken(ctx, req.(*ServiceAccount))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Token_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Token(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_Token_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Token(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Whoami",
			Handler:    _UserService_Whoami_Handler,
		},
		{
			MethodName: "CreateToken",
			Handler:    _UserService_CreateToken_Handler,
		},
		{
			MethodName: "Token",
			Handler:    _UserService_Token_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	FlavorService_List_FullMethodName = "/v1.FlavorService/List"
	FlavorService_Info_FullMethodName = "/v1.FlavorService/Info"
)

// FlavorServiceClient is the client API for FlavorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// FlavorService provides flavor based functionality.
type FlavorServiceClient interface {
	// List provides information about the available flavors.
	List(ctx context.Context, in *FlavorListRequest, opts ...grpc.CallOption) (*FlavorListResponse, error)
	// Info provides information about a specific flavor.
	Info(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*Flavor, error)
}

type flavorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFlavorServiceClient(cc grpc.ClientConnInterface) FlavorServiceClient {
	return &flavorServiceClient{cc}
}

func (c *flavorServiceClient) List(ctx context.Context, in *FlavorListRequest, opts ...grpc.CallOption) (*FlavorListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FlavorListResponse)
	err := c.cc.Invoke(ctx, FlavorService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flavorServiceClient) Info(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*Flavor, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Flavor)
	err := c.cc.Invoke(ctx, FlavorService_Info_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FlavorServiceServer is the server API for FlavorService service.
// All implementations must embed UnimplementedFlavorServiceServer
// for forward compatibility.
//
// FlavorService provides flavor based functionality.
type FlavorServiceServer interface {
	// List provides information about the available flavors.
	List(context.Context, *FlavorListRequest) (*FlavorListResponse, error)
	// Info provides information about a specific flavor.
	Info(context.Context, *ResourceByID) (*Flavor, error)
	mustEmbedUnimplementedFlavorServiceServer()
}

// UnimplementedFlavorServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFlavorServiceServer struct{}

func (UnimplementedFlavorServiceServer) List(context.Context, *FlavorListRequest) (*FlavorListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedFlavorServiceServer) Info(context.Context, *ResourceByID) (*Flavor, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}
func (UnimplementedFlavorServiceServer) mustEmbedUnimplementedFlavorServiceServer() {}
func (UnimplementedFlavorServiceServer) testEmbeddedByValue()                       {}

// UnsafeFlavorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FlavorServiceServer will
// result in compilation errors.
type UnsafeFlavorServiceServer interface {
	mustEmbedUnimplementedFlavorServiceServer()
}

func RegisterFlavorServiceServer(s grpc.ServiceRegistrar, srv FlavorServiceServer) {
	// If the following call pancis, it indicates UnimplementedFlavorServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FlavorService_ServiceDesc, srv)
}

func _FlavorService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlavorListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlavorServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FlavorService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlavorServiceServer).List(ctx, req.(*FlavorListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlavorService_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlavorServiceServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FlavorService_Info_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlavorServiceServer).Info(ctx, req.(*ResourceByID))
	}
	return interceptor(ctx, in, info, handler)
}

// FlavorService_ServiceDesc is the grpc.ServiceDesc for FlavorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FlavorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.FlavorService",
	HandlerType: (*FlavorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _FlavorService_List_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _FlavorService_Info_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	ClusterService_Info_FullMethodName      = "/v1.ClusterService/Info"
	ClusterService_List_FullMethodName      = "/v1.ClusterService/List"
	ClusterService_Lifespan_FullMethodName  = "/v1.ClusterService/Lifespan"
	ClusterService_Create_FullMethodName    = "/v1.ClusterService/Create"
	ClusterService_Artifacts_FullMethodName = "/v1.ClusterService/Artifacts"
	ClusterService_Delete_FullMethodName    = "/v1.ClusterService/Delete"
	ClusterService_Logs_FullMethodName      = "/v1.ClusterService/Logs"
)

// ClusterServiceClient is the client API for ClusterService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// FlavorService provides flavor based functionality.
type ClusterServiceClient interface {
	// Info provides information about a specific cluster.
	Info(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*Cluster, error)
	// List provides information about the available clusters.
	List(ctx context.Context, in *ClusterListRequest, opts ...grpc.CallOption) (*ClusterListResponse, error)
	// Lifespan updates the lifespan for a specific cluster.
	Lifespan(ctx context.Context, in *LifespanRequest, opts ...grpc.CallOption) (*durationpb.Duration, error)
	// Create launches a new cluster.
	Create(ctx context.Context, in *CreateClusterRequest, opts ...grpc.CallOption) (*ResourceByID, error)
	// Artifacts returns the artifacts for a specific cluster.
	Artifacts(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*ClusterArtifacts, error)
	// Delete deletes an existing cluster.
	Delete(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Logs returns the logs for a specific cluster.
	Logs(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*LogsResponse, error)
}

type clusterServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewClusterServiceClient(cc grpc.ClientConnInterface) ClusterServiceClient {
	return &clusterServiceClient{cc}
}

func (c *clusterServiceClient) Info(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*Cluster, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Cluster)
	err := c.cc.Invoke(ctx, ClusterService_Info_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) List(ctx context.Context, in *ClusterListRequest, opts ...grpc.CallOption) (*ClusterListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterListResponse)
	err := c.cc.Invoke(ctx, ClusterService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) Lifespan(ctx context.Context, in *LifespanRequest, opts ...grpc.CallOption) (*durationpb.Duration, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(durationpb.Duration)
	err := c.cc.Invoke(ctx, ClusterService_Lifespan_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) Create(ctx context.Context, in *CreateClusterRequest, opts ...grpc.CallOption) (*ResourceByID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResourceByID)
	err := c.cc.Invoke(ctx, ClusterService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) Artifacts(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*ClusterArtifacts, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterArtifacts)
	err := c.cc.Invoke(ctx, ClusterService_Artifacts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) Delete(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ClusterService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) Logs(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*LogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogsResponse)
	err := c.cc.Invoke(ctx, ClusterService_Logs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClusterServiceServer is the server API for ClusterService service.
// All implementations must embed UnimplementedClusterServiceServer
// for forward compatibility.
//
// FlavorService provides flavor based functionality.
type ClusterServiceServer interface {
	// Info provides information about a specific cluster.
	Info(context.Context, *ResourceByID) (*Cluster, error)
	// List provides information about the available clusters.
	List(context.Context, *ClusterListRequest) (*ClusterListResponse, error)
	// Lifespan updates the lifespan for a specific cluster.
	Lifespan(context.Context, *LifespanRequest) (*durationpb.Duration, error)
	// Create launches a new cluster.
	Create(context.Context, *CreateClusterRequest) (*ResourceByID, error)
	// Artifacts returns the artifacts for a specific cluster.
	Artifacts(context.Context, *ResourceByID) (*ClusterArtifacts, error)
	// Delete deletes an existing cluster.
	Delete(context.Context, *ResourceByID) (*emptypb.Empty, error)
	// Logs returns the logs for a specific cluster.
	Logs(context.Context, *ResourceByID) (*LogsResponse, error)
	mustEmbedUnimplementedClusterServiceServer()
}

// UnimplementedClusterServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedClusterServiceServer struct{}

func (UnimplementedClusterServiceServer) Info(context.Context, *ResourceByID) (*Cluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}
func (UnimplementedClusterServiceServer) List(context.Context, *ClusterListRequest) (*ClusterListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedClusterServiceServer) Lifespan(context.Context, *LifespanRequest) (*durationpb.Duration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Lifespan not implemented")
}
func (UnimplementedClusterServiceServer) Create(context.Context, *CreateClusterRequest) (*ResourceByID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedClusterServiceServer) Artifacts(context.Context, *ResourceByID) (*ClusterArtifacts, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Artifacts not implemented")
}
func (UnimplementedClusterServiceServer) Delete(context.Context, *ResourceByID) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedClusterServiceServer) Logs(context.Context, *ResourceByID) (*LogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logs not implemented")
}
func (UnimplementedClusterServiceServer) mustEmbedUnimplementedClusterServiceServer() {}
func (UnimplementedClusterServiceServer) testEmbeddedByValue()                        {}

// UnsafeClusterServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClusterServiceServer will
// result in compilation errors.
type UnsafeClusterServiceServer interface {
	mustEmbedUnimplementedClusterServiceServer()
}

func RegisterClusterServiceServer(s grpc.ServiceRegistrar, srv ClusterServiceServer) {
	// If the following call pancis, it indicates UnimplementedClusterServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ClusterService_ServiceDesc, srv)
}

func _ClusterService_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_Info_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).Info(ctx, req.(*ResourceByID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).List(ctx, req.(*ClusterListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_Lifespan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifespanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).Lifespan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_Lifespan_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).Lifespan(ctx, req.(*LifespanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).Create(ctx, req.(*CreateClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_Artifacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).Artifacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_Artifacts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).Artifacts(ctx, req.(*ResourceByID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).Delete(ctx, req.(*ResourceByID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_Logs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).Logs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_Logs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).Logs(ctx, req.(*ResourceByID))
	}
	return interceptor(ctx, in, info, handler)
}

// ClusterService_ServiceDesc is the grpc.ServiceDesc for ClusterService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClusterService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.ClusterService",
	HandlerType: (*ClusterServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Info",
			Handler:    _ClusterService_Info_Handler,
		},
		{
			MethodName: "List",
			Handler:    _ClusterService_List_Handler,
		},
		{
			MethodName: "Lifespan",
			Handler:    _ClusterService_Lifespan_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _ClusterService_Create_Handler,
		},
		{
			MethodName: "Artifacts",
			Handler:    _ClusterService_Artifacts_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ClusterService_Delete_Handler,
		},
		{
			MethodName: "Logs",
			Handler:    _ClusterService_Logs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	CliService_Upgrade_FullMethodName = "/v1.CliService/Upgrade"
)

// CliServiceClient is the client API for CliService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// CliService provides an upgrade path for the command line interface.
type CliServiceClient interface {
	// Upgrade - gets an updated binary if it exists.
	Upgrade(ctx context.Context, in *CliUpgradeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CliUpgradeResponse], error)
}

type cliServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCliServiceClient(cc grpc.ClientConnInterface) CliServiceClient {
	return &cliServiceClient{cc}
}

func (c *cliServiceClient) Upgrade(ctx context.Context, in *CliUpgradeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CliUpgradeResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CliService_ServiceDesc.Streams[0], CliService_Upgrade_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[CliUpgradeRequest, CliUpgradeResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CliService_UpgradeClient = grpc.ServerStreamingClient[CliUpgradeResponse]

// CliServiceServer is the server API for CliService service.
// All implementations must embed UnimplementedCliServiceServer
// for forward compatibility.
//
// CliService provides an upgrade path for the command line interface.
type CliServiceServer interface {
	// Upgrade - gets an updated binary if it exists.
	Upgrade(*CliUpgradeRequest, grpc.ServerStreamingServer[CliUpgradeResponse]) error
	mustEmbedUnimplementedCliServiceServer()
}

// UnimplementedCliServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCliServiceServer struct{}

func (UnimplementedCliServiceServer) Upgrade(*CliUpgradeRequest, grpc.ServerStreamingServer[CliUpgradeResponse]) error {
	return status.Errorf(codes.Unimplemented, "method Upgrade not implemented")
}
func (UnimplementedCliServiceServer) mustEmbedUnimplementedCliServiceServer() {}
func (UnimplementedCliServiceServer) testEmbeddedByValue()                    {}

// UnsafeCliServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CliServiceServer will
// result in compilation errors.
type UnsafeCliServiceServer interface {
	mustEmbedUnimplementedCliServiceServer()
}

func RegisterCliServiceServer(s grpc.ServiceRegistrar, srv CliServiceServer) {
	// If the following call pancis, it indicates UnimplementedCliServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CliService_ServiceDesc, srv)
}

func _CliService_Upgrade_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CliUpgradeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CliServiceServer).Upgrade(m, &grpc.GenericServerStream[CliUpgradeRequest, CliUpgradeResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CliService_UpgradeServer = grpc.ServerStreamingServer[CliUpgradeResponse]

// CliService_ServiceDesc is the grpc.ServiceDesc for CliService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CliService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.CliService",
	HandlerType: (*CliServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Upgrade",
			Handler:       _CliService_Upgrade_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}

const (
	InfraStatusService_GetStatus_FullMethodName   = "/v1.InfraStatusService/GetStatus"
	InfraStatusService_ResetStatus_FullMethodName = "/v1.InfraStatusService/ResetStatus"
	InfraStatusService_SetStatus_FullMethodName   = "/v1.InfraStatusService/SetStatus"
)

// InfraStatusServiceClient is the client API for InfraStatusService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// InfraStatusService provides information on the status of the server.
type InfraStatusServiceClient interface {
	// GetStatus gets the maintenance
	GetStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*InfraStatus, error)
	// ResetStatus resets the maintenance
	ResetStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*InfraStatus, error)
	// SetStatus sets the maintenance
	SetStatus(ctx context.Context, in *InfraStatus, opts ...grpc.CallOption) (*InfraStatus, error)
}

type infraStatusServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInfraStatusServiceClient(cc grpc.ClientConnInterface) InfraStatusServiceClient {
	return &infraStatusServiceClient{cc}
}

func (c *infraStatusServiceClient) GetStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*InfraStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InfraStatus)
	err := c.cc.Invoke(ctx, InfraStatusService_GetStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraStatusServiceClient) ResetStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*InfraStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InfraStatus)
	err := c.cc.Invoke(ctx, InfraStatusService_ResetStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraStatusServiceClient) SetStatus(ctx context.Context, in *InfraStatus, opts ...grpc.CallOption) (*InfraStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InfraStatus)
	err := c.cc.Invoke(ctx, InfraStatusService_SetStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InfraStatusServiceServer is the server API for InfraStatusService service.
// All implementations must embed UnimplementedInfraStatusServiceServer
// for forward compatibility.
//
// InfraStatusService provides information on the status of the server.
type InfraStatusServiceServer interface {
	// GetStatus gets the maintenance
	GetStatus(context.Context, *emptypb.Empty) (*InfraStatus, error)
	// ResetStatus resets the maintenance
	ResetStatus(context.Context, *emptypb.Empty) (*InfraStatus, error)
	// SetStatus sets the maintenance
	SetStatus(context.Context, *InfraStatus) (*InfraStatus, error)
	mustEmbedUnimplementedInfraStatusServiceServer()
}

// UnimplementedInfraStatusServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedInfraStatusServiceServer struct{}

func (UnimplementedInfraStatusServiceServer) GetStatus(context.Context, *emptypb.Empty) (*InfraStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatus not implemented")
}
func (UnimplementedInfraStatusServiceServer) ResetStatus(context.Context, *emptypb.Empty) (*InfraStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetStatus not implemented")
}
func (UnimplementedInfraStatusServiceServer) SetStatus(context.Context, *InfraStatus) (*InfraStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetStatus not implemented")
}
func (UnimplementedInfraStatusServiceServer) mustEmbedUnimplementedInfraStatusServiceServer() {}
func (UnimplementedInfraStatusServiceServer) testEmbeddedByValue()                            {}

// UnsafeInfraStatusServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InfraStatusServiceServer will
// result in compilation errors.
type UnsafeInfraStatusServiceServer interface {
	mustEmbedUnimplementedInfraStatusServiceServer()
}

func RegisterInfraStatusServiceServer(s grpc.ServiceRegistrar, srv InfraStatusServiceServer) {
	// If the following call pancis, it indicates UnimplementedInfraStatusServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&InfraStatusService_ServiceDesc, srv)
}

func _InfraStatusService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraStatusServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InfraStatusService_GetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraStatusServiceServer).GetStatus(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraStatusService_ResetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraStatusServiceServer).ResetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InfraStatusService_ResetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraStatusServiceServer).ResetStatus(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraStatusService_SetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfraStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraStatusServiceServer).SetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InfraStatusService_SetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraStatusServiceServer).SetStatus(ctx, req.(*InfraStatus))
	}
	return interceptor(ctx, in, info, handler)
}

// InfraStatusService_ServiceDesc is the grpc.ServiceDesc for InfraStatusService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InfraStatusService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.InfraStatusService",
	HandlerType: (*InfraStatusServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStatus",
			Handler:    _InfraStatusService_GetStatus_Handler,
		},
		{
			MethodName: "ResetStatus",
			Handler:    _InfraStatusService_ResetStatus_Handler,
		},
		{
			MethodName: "SetStatus",
			Handler:    _InfraStatusService_SetStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}
